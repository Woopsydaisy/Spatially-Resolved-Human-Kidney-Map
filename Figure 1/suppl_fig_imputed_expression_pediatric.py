# -*- coding: utf-8 -*-
"""Suppl Fig Imputed Expression Pediatric.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nRcOqDqKn9fKvKeKEqvxdCIxSXhte1TI
"""

!pip install --quiet scanpy
!pip install --quiet leidenalg
!pip install --quiet squidpy

import csv
import anndata as ad
import gzip
import os
import scipy.io
import scanpy as sc
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from google.colab import drive
import leidenalg as la
from pathlib import Path
import squidpy as sq
import scipy

adata = sc.read_h5ad('/content/drive/MyDrive/Bernhard/Cosmx/After_Cleaning/all_Cosmx_cleaned_neighbored.h5ad')

subset_adata=adata[adata.obs['sample']=='Pediatric1']

subset_adata.obs['fov']=subset_adata.obs['fov'].astype(int)

# fov_include is already a list
fov_include = [36, 37, 39, 40, 41, 44, 45, 46, 51, 52, 53, 60, 61, 62, 70, 71, 72, 81, 82, 83, 92, 93, 94, 103, 104, 105, 114, 115, 116, 125, 126,
               127, 136, 137, 138, 147, 148, 149, 157, 158, 159, 168, 169, 170, 179, 180, 181, 187, 188, 189, 197, 198, 199, 207, 208, 209, 217,
               218, 219, 226, 227, 228, 235, 236, 237, 245, 246, 247]

# Filter the data to include only FOVs in fov_include
filtered_data = subset_adata[subset_adata.obs['fov'].isin(fov_include)]

filtered_data

plt.style.use('seaborn-white')
markers = [ "REN"]

sc.pl.dotplot(filtered_data, markers, groupby='annotation_post_scanvi70_broad', cmap='Blues', log = False)

cluster_ids = filtered_data.obs['annotation_post_scanvi70_broad']

# Step 2: If it's not already a DataFrame, convert it (usually it's a Series)
# You can optionally include the index or other columns if needed
cluster_ids_df = cluster_ids.to_frame()

# Step 3: Export to CSV
cluster_ids_df.to_csv('cluster_ids.csv', index=True)  # index=True to include row indices in the CSV
cluster_ids_df

sc.pp.normalize_total(filtered_data, target_sum=1e4)
sc.pp.log1p(filtered_data)

dense_matrix = filtered_data.X.toarray()

# Create a DataFrame from the dense matrix
df_unimputed = pd.DataFrame(dense_matrix, index=filtered_data.obs.index, columns=filtered_data.var.index)

# Your list of columns to include
columns_to_include = ['ACSM2B', 'APOE', 'AZGP1', 'UMOD', 'CLDN5',
                     'KLRG2', 'NPHS2', 'NPHS1', 'REN', 'NOS1',
                     'SLC4A4', 'SLC12A1', 'SLC8', 'ITGA8', 'PLVAP', 'HECW2', 'TLL1']
# Step 1: Check which columns are available in adata.obs
available_columns = [col for col in columns_to_include if col in df_unimputed.columns]

# Step 2: Identify missing columns
missing_columns = [col for col in columns_to_include if col not in df_unimputed.columns]

# Step 3: Print out the missing columns
if missing_columns:
    print("The following columns are not present in the AnnData object:", missing_columns)

# Step 4: Create a DataFrame with the available columns
filtered_df_unimputed = df_unimputed[available_columns]
#filtered_df_unimputed

filtered_df_unimputed.columns = [col + '_unimputed' for col in filtered_df_unimputed.columns]

filtered_df_unimputed

imputed_ped=sc.read_h5ad('/content/drive/MyDrive/Bernhard/Cosmx/After_Cleaning/SuppFig_Imputation/Pediatric_subset.h5ad')

dense_matrix = imputed_ped.X.toarray()

# Create a DataFrame from the dense matrix
df_imputed = pd.DataFrame(dense_matrix, index=imputed_ped.obs.index, columns=imputed_ped.var.index)

# Your list of columns to include
# Step 1: Check which columns are available in adata.obs
available_columns = [col for col in columns_to_include if col in df_imputed.columns]

# Step 2: Identify missing columns
missing_columns = [col for col in columns_to_include if col not in df_imputed.columns]

# Step 3: Print out the missing columns
if missing_columns:
    print("The following columns are not present in the AnnData object:", missing_columns)

# Step 4: Create a DataFrame with the available columns
filtered_df_imputed = df_imputed[available_columns]
#filtered_df_imputed

filtered_df_imputed.columns = [col + '_imputed' for col in filtered_df_imputed.columns]

combined_df = pd.concat([filtered_df_unimputed, filtered_df_imputed], axis=1)
combined_df

from sklearn.preprocessing import MinMaxScaler
combined_df = combined_df.clip(lower=combined_df.quantile(0.01), upper=combined_df.quantile(0.99), axis=1)

# Apply MinMaxScaler
scaled_df = pd.DataFrame(
    MinMaxScaler().fit_transform(combined_df),
    columns=combined_df.columns,
    index=combined_df.index
)

#from sklearn.preprocessing import MinMaxScaler

# Step 1: Initialize the MinMaxScaler
#scaler = MinMaxScaler()

# Step 2: Fit the scaler to the data and transform it
#scaled_data = scaler.fit_transform(combined_df)

# Step 3: Create a new DataFrame with the scaled data, keeping the same column names and index
#scaled_df = pd.DataFrame(scaled_data, columns=combined_df.columns, index=combined_df.index)

print(scaled_df['ACSM2B_imputed'].max())

# Get the maximum value across all columns for the specific index
max_value = scaled_df.loc['Pediatric1_2_36-15'].max()

# Print the maximum value
print(max_value)

scaled_df

for col in combined_df.columns:
    del filtered_data.obs[col]
    filtered_data.obs[col] = scaled_df[col]

plt.style.use('dark_background')
for col in scaled_df.columns:
    sc.pl.scatter(
      filtered_data,
      x="CenterX_global_px",
      y="CenterY_global_px",
      color=col,
      title=f'{col}',
      size=2,
      color_map='plasma'
)

print(filtered_data.X)

filtered_data

filtered_data.obs['fov']=filtered_data.obs['fov'].astype(str)

sc.pl.scatter(
      filtered_data,
      x="CenterX_global_px",
      y="CenterY_global_px",
      color='fov',
      legend_loc='on data',
      size=5,
      color_map='plasma'
)

filtered_data.obs['fov']=filtered_data.obs['fov'].astype(int)

# fov_include is already a list
fov_include = [36, 39,  44,  51,  60,  70,  81,  92, 103, 114,  125, 136, 147, 157,  168,
                179,  187,  197, 207,  217,
                226,  235, 245]

# Filter the data to include only FOVs in fov_include
adata3 = filtered_data[filtered_data.obs['fov'].isin(fov_include)]

adata3

adata = sc.read_h5ad('/content/drive/MyDrive/Bernhard/Cosmx/After_Cleaning/raw_for_plotting/Pediatric1_raw.h5ad')

# Convert cell_id columns to sets
cell_ids_in_adata = set(adata.obs["cell_id"].to_list())
cell_ids_in_adata3 = set(adata3.obs["cell_id"].to_list())

# Find the intersection of cell IDs present in both objects
common_cell_ids = cell_ids_in_adata.intersection(cell_ids_in_adata3)

# Print the common cell IDs
#print(common_cell_ids)
mask = adata.obs["cell_id"].isin(common_cell_ids)
adata_subset = adata[mask]
adata_subset

for col in scaled_df.columns:
    # Create a dictionary from adata2 mapping cell_id to immune_cell_neighbor_calling
    immune_calling_map = adata3.obs.set_index('cell_id')[col].to_dict()

    # Map immune_cell_neighbor_calling values to adata_subset based on cell_id
    adata_subset.obs[col] = adata_subset.obs['cell_id'].map(immune_calling_map)

adata_subset

# Create a dictionary from adata2 mapping cell_id to immune_cell_neighbor_calling
immune_calling_map = adata3.obs.set_index('cell_id')['annotation_post_scanvi70_broad'].to_dict()

# Map immune_cell_neighbor_calling values to adata_subset based on cell_id
adata_subset.obs['annotation_post_scanvi70_broad'] = adata_subset.obs['cell_id'].map(immune_calling_map)

adata_subset.obs["annotation_post_scanvi70_broad"]=adata_subset.obs["annotation_post_scanvi70_broad"].astype('category')

cell_colors = {'PC': (0.12156862745098039, 0.4666666666666667, 0.7058823529411765),
               'CNT': (0.6823529411764706, 0.7803921568627451, 0.9098039215686274),
               'DCT': (1.0, 0.4980392156862745, 0.054901960784313725),
               'DTL_ATL': (1.0, 0.7333333333333333, 0.47058823529411764),
               'EC_DVR': (0.17254901960784313, 0.6274509803921569, 0.17254901960784313),
               'EC_Peritub': (0.596078431372549, 0.8745098039215686, 0.5411764705882353),
               'EC_glom': (0.8392156862745098, 0.15294117647058825, 0.1568627450980392),
               'IC A': (1.0, 0.596078431372549, 0.5882352941176471),
               'IC B': (0.5803921568627451, 0.403921568627451, 0.7411764705882353),
               'Immune': (0.7725490196078432, 0.6901960784313725, 0.8352941176470589),
               'Podo': (0.5490196078431373, 0.33725490196078434, 0.29411764705882354),
               'Fibroblast': (0.7686274509803922, 0.611764705882353, 0.5803921568627451),
               'PEC': (0.8901960784313725, 0.4666666666666667, 0.7607843137254902),
               'PT': (0.9686274509803922, 0.7137254901960784, 0.8235294117647058),
               'MC1': (0.4980392156862745, 0.4980392156862745, 0.4980392156862745),
               'iPT': (0.7803921568627451, 0.7803921568627451, 0.7803921568627451),
               'iTAL': (0.8588235294117647, 0.8588235294117647, 0.5529411764705883),
               'TAL': (0.09019607843137255, 0.7450980392156863, 0.8117647058823529),
               'VSMC': (0.6196078431372549, 0.8549019607843137, 0.8980392156862745),
                'outlier':(0.2, 0.2, 0.2)
               #'CD4+ T Cells': (0.5529411764705883, 0.8274509803921568, 0.7803921568627451),
                #'Baso/Mast':(0.2235, 0.2314, 0.4745),
                #'B Cells':(0.7450980392156863, 0.7294117647058823, 0.8549019607843137),
                #'CD8+ T Cells':(0.6784, 0.2863, 0.2902),
                #'MDC':(0.9921568627450981, 0.7058823529411765, 0.3843137254901961),
                #'Neutrophil':(0.9882352941176471, 0.803921568627451, 0.8980392156862745),
                #'Mac M2':(0.3, 0.3, 0.3),
                #'NK Cells':(0.7372549019607844, 0.5019607843137255, 0.7411764705882353),

}

adata_subset.obsm['X_umap']=adata3.obsm['X_umap'].copy()

sc.pl.umap(adata_subset, color='annotation_post_scanvi70_broad', palette=cell_colors)

adata_subset.obs['fov']=adata_subset.obs['fov'].astype(str)

plt.style.use('dark_background')
adata_list = [adata_subset]
for adata in adata_list:
    adata_name = adata.obs["fov"].unique().astype(str)
    for fov in adata.obs['fov'].unique():
        ax = sq.pl.spatial_segment(
            adata,
            color="annotation_post_scanvi70_broad",
            library_key="fov",
            library_id=fov,
            seg_cell_id="cell_ID",
            seg_outline=True,
            img=False,
            title='',
            axis_label='',
            return_ax=True,
            frameon=False,
            vmax = 1.3,
            vmin = 0,
            colorbar=False,
            cmap='plasma'
        )

        # Set the visibility of the spines to False
        for spine in ax.spines.values():
            spine.set_visible(False)

        # Remove the legend, if present
        if ax.get_legend():
            ax.get_legend().remove()

        # Corrected filename construction with string formatting
        filename = f'/content/drive/MyDrive/Bernhard/Cosmx/After_Cleaning/SuppFig_Imputation/annotation_{fov}_pediatric.png'

        # When saving, also specify the bbox_inches parameter to eliminate any extra white space
        plt.savefig(filename, dpi=450, bbox_inches='tight', pad_inches=0)
        plt.show()

plt.style.use('dark_background')
adata_list = [adata_subset]
for col in scaled_df.columns:
  for adata in adata_list:
    adata_name = adata.obs["fov"].unique().astype(str)
    for fov in adata.obs['fov'].unique():
        ax = sq.pl.spatial_segment(
            adata,
            color=col,
            library_key="fov",
            library_id=fov,
            seg_cell_id="cell_ID",
            seg_outline=True,
            img=False,
            title='',
            axis_label='',
            return_ax=True,
            frameon=False,
            vmax = 1,
            vmin = 0,
            colorbar=False,
            cmap='plasma'
        )

        # Set the visibility of the spines to False
        for spine in ax.spines.values():
            spine.set_visible(False)

        # Remove the legend, if present
        if ax.get_legend():
            ax.get_legend().remove()

        # Corrected filename construction with string formatting
        filename = f'/content/drive/MyDrive/Bernhard/Cosmx/After_Cleaning/SuppFig_Imputation/{col}_{fov}_pediatric.png'

        # When saving, also specify the bbox_inches parameter to eliminate any extra white space
        plt.savefig(filename, dpi=450, bbox_inches='tight', pad_inches=0)
        plt.show()