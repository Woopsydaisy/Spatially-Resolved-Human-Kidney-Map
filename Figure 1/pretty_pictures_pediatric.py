# -*- coding: utf-8 -*-
"""Pretty Pictures Pediatric.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cR9XBJnNTwd6A6SchycWicQmHdb1NJ-3
"""

!pip install --quiet scanpy
!pip install --quiet leidenalg
!pip install --quiet squidpy

import csv
import anndata as ad
import gzip
import os
import scipy.io
import scanpy as sc
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from google.colab import drive
import leidenalg as la
from pathlib import Path
import squidpy as sq
import scipy

adata = sc.read_h5ad('/content/drive/MyDrive/Bernhard/Cosmx/After_Cleaning/raw_for_plotting/Pediatric1_raw.h5ad')

adata3= sc.read_h5ad('/content/drive/MyDrive/Bernhard/Cosmx/After_Cleaning/all_Cosmx_cleaned_neighbored.h5ad')

adata3 = adata3[adata3.obs["sample"]=="Pediatric1"]

# Convert cell_id columns to sets
cell_ids_in_adata = set(adata.obs["cell_id"].to_list())
cell_ids_in_adata3 = set(adata3.obs["cell_id"].to_list())

# Find the intersection of cell IDs present in both objects
common_cell_ids = cell_ids_in_adata.intersection(cell_ids_in_adata3)

# Print the common cell IDs
#print(common_cell_ids)
mask = adata.obs["cell_id"].isin(common_cell_ids)
adata_subset = adata[mask]
adata_subset

# Create a dictionary from adata2 mapping cell_id to immune_cell_neighbor_calling
immune_calling_map = adata3.obs.set_index('cell_id')['annotation_post_scanvi70_broad'].to_dict()

# Map immune_cell_neighbor_calling values to adata_subset based on cell_id
adata_subset.obs['annotation_post_scanvi70_broad'] = adata_subset.obs['cell_id'].map(immune_calling_map)

# fov_include is already a list
fov_include = [39, 40, 41, 44, 45, 46, 51, 52, 53, 60, 61, 62, 70, 71, 72, 81, 82, 83, 92, 93, 94, 103, 104, 105, 114, 115, 116, 125, 126,
               127, 136, 137, 138, 147, 148, 149, 157, 158, 159, 168, 169, 170, 179, 180, 181, 187, 188, 189, 197, 198, 199, 207, 208, 209, 217,
               218, 219, 226, 227, 228, 235, 236, 237, 245, 246, 247]

# Filter the data to include only FOVs in fov_include
adata_subset2 = adata_subset[adata_subset.obs['fov'].isin(fov_include)]



print(adata_subset2.obs["fov"])

adata_subset2.obs["fov"]=adata_subset2.obs["fov"].astype(str)

adata_subset2.write('/content/drive/MyDrive/Bernhard/Cosmx/After_Cleaning/raw_for_plotting/Pediatric1_raw_precut.h5ad')

adata_subset2= sc.read_h5ad('/content/drive/MyDrive/Bernhard/Cosmx/After_Cleaning/raw_for_plotting/Pediatric1_raw_precut.h5ad')



# Commented out IPython magic to ensure Python compatibility.
# %config InlineBackend.figure_format='retina'
plt.style.use('dark_background')

sq.pl.spatial_segment(
    adata_subset2,
    color="annotation_post_scanvi70_broad",
    library_key="fov",
    library_id=['168'],
    seg_cell_id="cell_ID",
    seg_outline=True,
    img=False,
    scalebar_dx=0.12,
    scalebar_kwargs={"scale_loc": "bottom", "location": "upper right"},
    legend_fontsize='xx-small'
)

adata_subset2

cell_colors = {"PC": "#c6dbef",
               "CNT": "#bcbddc",
               "DCT": "#3182bd",
               "DTL_ATL": "navy",
               "EC_DVR": "seagreen",
                "EC_Peritub": "grey",
               "EC_glom": "yellow",
               "IC A": "orange",
               "IC B": "#fdd0a2",
               "Immune": "#c7e9c0",
               "Podo": "#000004",
               "Fibroblast": "limegreen",
               "PEC": "#fde725",
               "PT": "royalblue",
               "MC1": "lightcoral",
               "iPT": "darkorchid",
               "prolif_Tubule": "darkred",
               "iTAL": "crimson",
               "TAL": "#0000cc",
                "VSMC":"pink"
              }

cell_colors = {
 'PC': '#1f77b4',
 'CNT': '#aec7e8',
 'DCT': '#ff7f0e',
 'DTL_ATL': '#ffbb78',
 'EC_DVR': '#2ca02c',
 'EC_Peritub': '#98df8a',
 'EC_glom': '#d62728',
 'IC A': '#ff9896',
 'IC B': '#9467bd',
 'Immune': '#c5b0d5',
 'Podo': '#8c564b',
 'Fibroblast': '#c49c94',
 'PEC': '#e377c2',
 'PT': '#f7b6d2',
 'MC1': '#7f7f7f',
 'iPT': '#c7c7c7',
 'prolif_Tubule': '#bcbd22',
 'iTAL': '#dbdb8d',
 'TAL': '#17becf',
 'VSMC': '#9edae5'
}

import matplotlib.pyplot as plt

# Get the tab20 colormap
tab20_colors = plt.cm.tab20.colors

# Assign each cell type a color from tab20, cycling through if there are more cell types than colors
cell_types = list(cell_colors.keys())
tab20_cell_colors = {cell_type: tab20_colors[i % len(tab20_colors)] for i, cell_type in enumerate(cell_types)}

# Now tab20_cell_colors is your new color dictionary with colors from tab20
print(tab20_cell_colors)



cell_colors = {'PC': (0.12156862745098039, 0.4666666666666667, 0.7058823529411765),
               'CNT': (0.6823529411764706, 0.7803921568627451, 0.9098039215686274),
               'DCT': (1.0, 0.4980392156862745, 0.054901960784313725),
               'DTL_ATL': (1.0, 0.7333333333333333, 0.47058823529411764),
               'EC_DVR': (0.17254901960784313, 0.6274509803921569, 0.17254901960784313),
               'EC_Peritub': (0.596078431372549, 0.8745098039215686, 0.5411764705882353),
               'EC_glom': (0.8392156862745098, 0.15294117647058825, 0.1568627450980392),
               'IC A': (1.0, 0.596078431372549, 0.5882352941176471),
               'IC B': (0.5803921568627451, 0.403921568627451, 0.7411764705882353),
               'Immune': (0.7725490196078432, 0.6901960784313725, 0.8352941176470589),
               'Podo': (0.5490196078431373, 0.33725490196078434, 0.29411764705882354),
               'Fibroblast': (0.7686274509803922, 0.611764705882353, 0.5803921568627451),
               'PEC': (0.8901960784313725, 0.4666666666666667, 0.7607843137254902),
               'PT': (0.9686274509803922, 0.7137254901960784, 0.8235294117647058),
               'MC1': (0.4980392156862745, 0.4980392156862745, 0.4980392156862745),
               'iPT': (0.7803921568627451, 0.7803921568627451, 0.7803921568627451),
               'iTAL': (0.8588235294117647, 0.8588235294117647, 0.5529411764705883),
               'TAL': (0.09019607843137255, 0.7450980392156863, 0.8117647058823529),
               'VSMC': (0.6196078431372549, 0.8549019607843137, 0.8980392156862745)}


from matplotlib.colors import ListedColormap
cell_type_order = adata_subset2.obs["annotation_post_scanvi70_broad"].cat.categories
colors_for_palette = [cell_colors.get(cell_type, '#000000') for cell_type in cell_type_order]
custom_cmap = ListedColormap(colors_for_palette)

adata_subset2

print(adata_subset2.uns['annotation_post_scanvi70_broad_colors'])

adata_subset2.uns['annotation_post_scanvi70_broad_colors'] = pd.Categorical(adata_subset2.uns['annotation_post_scanvi70_broad_colors'], categories=['#aec7e8',
                                                                                                                                            '#ff7f0e',
                                                                                                                                            '#ffbb78',
                                                                                                                                            '#2ca02c',
                                                                                                                                            '#98df8a',
                                                                                                                                            '#d62728',
                                                                                                                                            '#c49c94',
                                                                                                                                            '#ff9896',
                                                                                                                                            '#9467bd',
                                                                                                                                            '#c5b0d5',
                                                                                                                                            '#7f7f7f',
                                                                                                                                            '#1f77b4',
                                                                                                                                            '#e377c2',
                                                                                                                                            '#f7b6d2',
                                                                                                                                            '#8c564b',
                                                                                                                                            '#17becf',
                                                                                                                                            '#9edae5',
                                                                                                                                            '#c7c7c7',
                                                                                                                                            '#dbdb8d'])

# Assuming 'cell_colors' and 'cell_type_order' are defined as before
# Ensure 'cell_type_order' matches the categories in your annotation
cell_type_order = adata_subset2.obs["annotation_post_scanvi70_broad"].cat.categories.tolist()

# Directly map categories to colors
colors_mapped = [cell_colors[cell_type] for cell_type in cell_type_order]

# Assign mapped colors to 'annotation_post_scanvi70_broad_colors' in the .uns slot
adata_subset2.uns['annotation_post_scanvi70_broad_colors'] = colors_mapped

print(custom_cmap)



# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import squidpy as sq

# Set the figure parameters for a better resolution
# %config InlineBackend.figure_format='retina'
plt.style.use('dark_background')

# Assuming `adata_subset2` is your AnnData object
fov_include_2 = ['39','44',  '51', '60', '70', '81' , '92',  '103', '114',  '125',
               '136',  '147', '157', '168', '179', '187' , '197' , '207', '217',
               '226', '235', '245']

for library_id in fov_include_2:
    sq.pl.spatial_segment(
        adata_subset2,
        color="annotation_post_scanvi70_broad",
        library_key="fov",
        library_id=[library_id],
        seg_cell_id="cell_ID",
        seg_outline=True,
        img=False,
        #scalebar_dx=0.12,
        scalebar_kwargs={"scale_loc": "bottom", "location": "upper right"},
        #legend_fontsize='xx-small',
        palette=custom_cmap,
        return_ax=False,
        title='',
        axis_label='',
        frameon=False

    ) # Remove the legend
    plt.show()  # This will display the plot for the current library_id before proceeding to the next

fov_include_2 = ['39','44',  '51', '60', '70', '81' , '92',  '103', '114',  '125',
               '136',  '147', '157', '168', '179', '187' , '197' , '207']

for library_id in fov_include_2:
    print(library_id)
    ax = sq.pl.spatial_segment(
        adata_subset2,
        color="annotation_post_scanvi70_broad",
        library_key="fov",
        library_id=[library_id],
        seg_cell_id="cell_ID",
        seg_outline=True,
        img=False,
        title='',
        axis_label='',
        return_ax=True,
        frameon=False # Ensure this is set to True
    )
    ax.legend().remove()  # Remove the legend
    plt.show()

fov_include_2 = ['125', '136',  '147', '157', '168', '179', '187' , '197' , '207']
#from 125 down to 197

fov_include_3 = [ '126','137',  '148',  '158',  '169',  '180',  '188', '198']



for library_id in fov_include_3:
    print(library_id)
    ax = sq.pl.spatial_segment(
        adata_subset2,
        color="annotation_post_scanvi70_broad",
        library_key="fov",
        library_id=[library_id],
        seg_cell_id="cell_ID",
        seg_outline=True,
        img=False,
        title='',
        axis_label='',
        return_ax=True,
        frameon=False # Ensure this is set to True
    )
    ax.legend().remove()  # Remove the legend
    plt.show()

fov_include_2 = ['125', '136',  '147', '157', '168', '179', '187' , '197' ]
#from 125 down to 197

fov_include_3 = [ '126','137',  '148',  '158',  '169',  '180',  '188', '198']

fov_include_4 = ['127', '138',  '149', '159',  '170', '181',  '189', '199']



for library_id in fov_include_4:
    print(library_id)
    ax = sq.pl.spatial_segment(
        adata_subset2,
        color="annotation_post_scanvi70_broad",
        library_key="fov",
        library_id=[library_id],
        seg_cell_id="cell_ID",
        seg_outline=True,
        img=False,
        title='',
        axis_label='',
        return_ax=True,
        frameon=False # Ensure this is set to True
    )
    ax.legend().remove()  # Remove the legend
    plt.show()

import matplotlib.pyplot as plt
import squidpy as sq

# Apply dark background style
plt.style.use('dark_background')

# Manually adjust the background color to be transparent for subsequent plots
plt.rcParams['figure.facecolor'] = 'none'  # For the figure background
plt.rcParams['axes.facecolor'] = 'none'  # For the axes background
plt.rcParams['savefig.facecolor'] = 'none'  # For the saved figures

fov_include_2 = ['125', '136',  '147', '157', '168', '179', '187' , '197' ]
#from 125 down to 197

fov_include_3 = [ '126','137',  '148',  '158',  '169',  '180',  '188', '198']

fov_include_4 = ['127', '138',  '149', '159',  '170', '181',  '189', '199']

for library_id in fov_include_2:
    print(library_id)
    ax = sq.pl.spatial_segment(
        adata_subset2,
        color="annotation_post_scanvi70_broad",
        library_key="fov",
        library_id=[library_id],
        seg_cell_id="cell_ID",
        seg_outline=True,
        img=False,
        title='',
        axis_label='',
        return_ax=True,
        frameon=False
    )

    # Remove the legend, if present
    if ax.get_legend():
        ax.get_legend().remove()

    plt.show()



import matplotlib.pyplot as plt
import squidpy as sq

# Apply dark background style
plt.style.use('dark_background')

# Manually adjust the background color to be transparent for subsequent plots
plt.rcParams['figure.facecolor'] = 'none'  # For the figure background
plt.rcParams['axes.facecolor'] = 'none'  # For the axes background
plt.rcParams['savefig.facecolor'] = 'none'  # For the saved figures


for library_id in fov_include_3:
    print(library_id)
    ax = sq.pl.spatial_segment(
        adata_subset2,
        color="annotation_post_scanvi70_broad",
        library_key="fov",
        library_id=[library_id],
        seg_cell_id="cell_ID",
        seg_outline=True,
        img=False,
        title='',
        axis_label='',
        return_ax=True,
        frameon=False
    )

    # Remove the legend, if present
    if ax.get_legend():
        ax.get_legend().remove()

    plt.show()

import matplotlib.pyplot as plt
import squidpy as sq

# Apply dark background style
plt.style.use('dark_background')

# Manually adjust the background color to be transparent for subsequent plots
plt.rcParams['figure.facecolor'] = 'none'  # For the figure background
plt.rcParams['axes.facecolor'] = 'none'  # For the axes background
plt.rcParams['savefig.facecolor'] = 'none'  # For the saved figures


for library_id in fov_include_4:
    print(library_id)
    ax = sq.pl.spatial_segment(
        adata_subset2,
        color="annotation_post_scanvi70_broad",
        library_key="fov",
        library_id=[library_id],
        seg_cell_id="cell_ID",
        seg_outline=True,
        img=False,
        title='',
        axis_label='',
        return_ax=True,
        frameon=False
    )

    # Remove the legend, if present
    if ax.get_legend():
        ax.get_legend().remove()

    plt.show()

import matplotlib.pyplot as plt
import squidpy as sq

# Apply dark background style
plt.style.use('dark_background')

# Manually adjust the background color to be transparent for subsequent plots
plt.rcParams['figure.facecolor'] = 'none'  # For the figure background
plt.rcParams['axes.facecolor'] = 'none'  # For the axes background
plt.rcParams['savefig.facecolor'] = 'none'  # For the saved figures

fov_include_2 = ['39', '44', '51', '60', '70', '81', '92', '103', '114', '125', '136', '147', '157', '168', '179', '187', '197', '207']

for library_id in fov_include_2:
    print(library_id)
    ax = sq.pl.spatial_segment(
        adata_subset2,
        color="annotation_post_scanvi70_broad",
        library_key="fov",
        library_id=[library_id],
        seg_cell_id="cell_ID",
        seg_outline=True,
        img=False,
        title='',
        axis_label='',
        return_ax=True,
        frameon=False
    )

    # Remove the legend, if present
    if ax.get_legend():
        ax.get_legend().remove()

    plt.show()

import matplotlib.pyplot as plt
import squidpy as sq

# Apply dark background style
plt.style.use('dark_background')

# Manually adjust the background color to be transparent for subsequent plots
plt.rcParams['figure.facecolor'] = 'none'  # For the figure background
plt.rcParams['axes.facecolor'] = 'none'  # For the axes background
plt.rcParams['savefig.facecolor'] = 'none'  # For the saved figures

fov_include_2 = ['125', '136',  '147', '157', '168', '179', '187' , '197' ]
#from 125 down to 197

fov_include_3 = [ '126','137',  '148',  '158',  '169',  '180',  '188', '198']

fov_include_4 = ['127', '138',  '149', '159',  '170', '181',  '189', '199']
fov_include_5=['168']

for library_id in fov_include_5:
    print(library_id)
    ax = sq.pl.spatial_segment(
        adata_subset2,
        color="annotation_post_scanvi70_broad",
        library_key="fov",
        library_id=['169'],
        seg_cell_id="cell_ID",
        seg_outline=True,
        img=False,
        title='',
        axis_label='',
        scalebar_dx=0.12,
        scalebar_kwargs={"scale_loc": "bottom", "location": "upper left"},
        return_ax=True,
        frameon=False
    )

    # Remove the legend, if present
    if ax.get_legend():
        ax.get_legend().remove()

    plt.show()

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import squidpy as sq

# Set the figure parameters for a better resolution
# %config InlineBackend.figure_format='retina'
plt.style.use('dark_background')

# Assuming `adata_subset2` is your AnnData object
fov_include_2 = ['207',] #'44',  '51', '60', '70', '81' , '92',  '103', '114',  '125',
               #'136']#,  147, 157, 168, 179, 187 , 197 , 207, 217,
               #226, 235, 245

for library_id in fov_include_2:
    sq.pl.spatial_segment(
        adata_subset2,
        color="annotation_post_scanvi70_broad",
        library_key="fov",
        library_id=[library_id],
        seg_cell_id="cell_ID",
        seg_outline=True,
        img=False,
        scalebar_dx=0.12,
        scalebar_kwargs={"scale_loc": "bottom", "location": "upper right"},
        legend_fontsize='xx-small',
        frameon=False

    )
    plt.show()  # This will display the plot for the current library_id before proceeding to the next

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import squidpy as sq

# Set the figure parameters for a better resolution
# %config InlineBackend.figure_format='retina'
plt.style.use('dark_background')

# Assuming `adata_subset2` is your AnnData object
fov_include_2 = ['44',  '51', '60', '70', '81' , '92',  '103', '114',  '125']
               #'136']#,  147, 157, 168, 179, 187 , 197 , 207, 217,
               #226, 235, 245

for library_id in fov_include_2:
    sq.pl.spatial_segment(
        adata_subset2,
        color="annotation_post_scanvi70_broad",
        library_key="fov",
        library_id=[library_id],
        seg_cell_id="cell_ID",
        seg_outline=True,
        img=False,
        #scalebar_dx=0.12,
        scalebar_kwargs={"scale_loc": "bottom", "location": "upper right"},
        legend_fontsize='xx-small',
        palette=custom_cmap,
        frameon=False

    )
    plt.show()  # This will display the plot for the current library_id before proceeding to the next

print(library_ids)

adata_subset2.obs["fov"]=adata_subset2.obs["fov"].astype(int)



# fov_include is already a list
fov_include = [39, 44,  51, 60, 70, 81 , 92,  103, 114,  125,
               136,  147, 157, 168, 179, 187 , 197 , 207, 217,
               226, 235, 245]

# Filter the data to include only FOVs in fov_include
adata_subset2 = adata_subset2[adata_subset2.obs['fov'].isin(fov_include)]

adata_subset2.obs["fov"]=adata_subset2.obs["fov"].astype(str)

sc.pl.scatter(
    adata_subset2,
    x="CenterX_global_px",
    y="CenterY_global_px",
    color="annotation_post_scanvi70_broad",
    size=4, legend_fontsize=6,
    legend_fontoutline=2,
)

sc.pl.scatter(
    adata_subset2,
    x="CenterX_global_px",
    y="CenterY_global_px",
    color="fov",
    size=4, legend_fontsize=6,
    legend_fontoutline=2,
)









adata.obs["sample"]='HK2695'

adata3= sc.read_h5ad('/content/drive/MyDrive/Bernhard/Cosmx/After_Cleaning/all_Cosmx_cleaned_neighbored_100.h5ad')

# Create a new column based on condition
adata3.obs['immune_cell_neighbor_calling'] = adata3.obs.apply(
    lambda row: row['annotations_from_single_cell'] if row['annotation_post_scanvi70_broad'] == 'Immune'
    else row['annotation_post_scanvi70_broad'], axis=1
)

adata3=adata3[adata3.obs["sample"]=="Pediatric1"]

adata3.obs["immune_cell_neighbor_calling"]=adata3.obs["immune_cell_neighbor_calling"].astype('category')

# Convert cell_id columns to sets
cell_ids_in_adata = set(adata.obs["cell_id"].to_list())
cell_ids_in_adata3 = set(adata3.obs["cell_id"].to_list())

# Find the intersection of cell IDs present in both objects
common_cell_ids = cell_ids_in_adata.intersection(cell_ids_in_adata3)

# Print the common cell IDs
#print(common_cell_ids)
mask = adata.obs["cell_id"].isin(common_cell_ids)
adata_subset = adata[mask]
adata_subset

# Create a dictionary from adata2 mapping cell_id to immune_cell_neighbor_calling
immune_calling_map = adata3.obs.set_index('cell_id')['immune_cell_neighbor_calling'].to_dict()

# Map immune_cell_neighbor_calling values to adata_subset based on cell_id
adata_subset.obs['immune_cell_neighbor_calling'] = adata_subset.obs['cell_id'].map(immune_calling_map)

# Create a dictionary from adata2 mapping cell_id to immune_cell_neighbor_calling
immune_calling_map = adata3.obs.set_index('cell_id')['cluster_labels_anatomic'].to_dict()

# Map immune_cell_neighbor_calling values to adata_subset based on cell_id
adata_subset.obs['cluster_labels_anatomic'] = adata_subset.obs['cell_id'].map(immune_calling_map)

sc.pl.scatter(
    adata_subset,
    x="CenterX_global_px",
    y="CenterY_global_px",
    color="fov",
    size=1,
    legend_loc = 'on data', legend_fontsize=12,
    legend_fontoutline=2
)

adata_subset.obs["immune_cell_neighbor_calling"]=adata_subset.obs["immune_cell_neighbor_calling"].astype('category')

adata_subset.obs["fov"]=adata_subset.obs["fov"].astype('string')
adata_subset.obs["fov"]=adata_subset.obs["fov"].astype('category')

adata_subset.obs["fov"]=adata_subset.obs["fov"].astype(int)

# fov_include is already a list
fov_include = [39, 40, 41, 44, 45, 46, 51, 52, 53, 60, 61, 62, 70, 71, 72, 81, 82, 83, 92, 93, 94, 103, 104, 105, 114, 115, 116, 125, 126,
               127, 136, 137, 138, 147, 148, 149, 157, 158, 159, 168, 169, 170, 179, 180, 181, 187, 188, 189, 197, 198, 199, 207, 208, 209, 217,
               218, 219, 226, 227, 228, 235, 236, 237, 245, 246, 247]

# Filter the data to include only FOVs in fov_include
adata_subset2 = adata_subset[adata_subset.obs['fov'].isin(fov_include)]

adata_subset2.write('/content/drive/MyDrive/Bernhard/Cosmx/After_Cleaning/raw_for_plotting/Pediatric1_raw_precut.h5ad')

adata_subset2.obs["fov"]=adata_subset2.obs["fov"].astype('string')
adata_subset2.obs["fov"]=adata_subset2.obs["fov"].astype('category')

adata_subset2

print(adata_subset2.obs["annotations_"])

import gc
gc.collect()

# Commented out IPython magic to ensure Python compatibility.
# %config InlineBackend.figure_format='retina'
plt.style.use('dark_background')

sq.pl.spatial_segment(
    adata_subset2,
    color="immune_cell_neighbor_calling",
    library_key="fov",
    library_id=["52"],
    seg_cell_id="cell_ID",
    seg_outline=True,
    img=False,
    scalebar_dx=0.12,
    scalebar_kwargs={"scale_loc": "bottom", "location": "upper right"},
    legend_fontsize='xx-small'
)













#adata2 = sc.read_h5ad('/content/drive/MyDrive/Bernhard/Cosmx/After_Cleaning/all_Cosmx_cleaned_neighbored.h5ad')
adata2 = sc.read_h5ad('/content/drive/MyDrive/Bernhard/Cosmx/After_Cleaning/Neighborhood_PT/Neighborhood_PT.h5ad')

adata3=sc.read_h5ad('/content/drive/MyDrive/Bernhard/Cosmx/After_Cleaning/all_Cosmx_cleaned_neighbored.h5ad')

# Create a new column based on condition
adata3.obs['immune_cell_neighbor_calling'] = adata3.obs.apply(
    lambda row: row['annotations_from_single_cell'] if row['annotation_post_scanvi70_broad'] == 'Immune'
    else row['annotation_post_scanvi70_broad'], axis=1
)

adata3=adata3[adata3.obs["sample"]=="HK2695"]

adata3.obs["immune_cell_neighbor_calling"]=adata3.obs["immune_cell_neighbor_calling"].astype('category')

# Convert cell_id columns to sets
cell_ids_in_adata = set(adata.obs["cell_id"].to_list())
cell_ids_in_adata3 = set(adata3.obs["cell_id"].to_list())

# Find the intersection of cell IDs present in both objects
common_cell_ids = cell_ids_in_adata.intersection(cell_ids_in_adata3)

# Print the common cell IDs
#print(common_cell_ids)
mask = adata.obs["cell_id"].isin(common_cell_ids)
adata_subset = adata[mask]

# Create a dictionary from adata2 mapping cell_id to immune_cell_neighbor_calling
immune_calling_map = adata3.obs.set_index('cell_id')['immune_cell_neighbor_calling'].to_dict()

# Map immune_cell_neighbor_calling values to adata_subset based on cell_id
adata_subset.obs['immune_cell_neighbor_calling'] = adata_subset.obs['cell_id'].map(immune_calling_map)

# Create a dictionary from adata2 mapping cell_id to immune_cell_neighbor_calling
immune_calling_map = adata2.obs.set_index('cell_id')['PT_neighborhood_cluster'].to_dict()

# Map immune_cell_neighbor_calling values to adata_subset based on cell_id
adata_subset.obs['PT_neighborhood_cluster'] = adata_subset.obs['cell_id'].map(immune_calling_map)

adata_subset.obs["combined_neighborhood"] = adata_subset.obs["PT_neighborhood_cluster"].fillna(adata_subset.obs["immune_cell_neighbor_calling"])

print(adata_subset.obs["PT_neighborhood_cluster"])

adata2=adata2[adata2.obs["sample"]=="HK2695"]



# Create a dictionary from adata2 mapping cell_id to immune_cell_neighbor_calling
immune_calling_map = adata2.obs.set_index('cell_id')['PT_neighborhood_cluster'].to_dict()

# Map immune_cell_neighbor_calling values to adata_subset based on cell_id
adata_subset.obs['PT_neighborhood_cluster'] = adata_subset.obs['cell_id'].map(immune_calling_map)

adata_subset.obs["fov"]=adata_subset.obs["fov"].astype('str')

print(adata_subset.obs['immune_cell_neighbor_calling'].unique())

for annotation in adata_subset.obs['immune_cell_neighbor_calling'].unique():
  print(annotation)

cell_colors = {
    "EC_Peritub": "#1f77b4",
    "CD4+ T Cells": "#ff7f0e",
    "CNT": "#2ca02c",
    "PT": "#d62728",
    "TAL": "#9467bd",
    "IC A": "#8c564b",
    "iPT": "#e377c2",
    "DCT": "#7f7f7f",
    "Fibroblast": "#bcbd22",
    "PC": "#17becf",
    "IC B": "#1f77b4",
    "iTAL": "#ff7f0e",
    "CD8+ T Cells": "#2ca02c",
    "transitioning Mono/Macrophages": "#d62728",
    "EC_glom": "#9467bd",
    "Podo": "#8c564b",
    "NK Cells": "#e377c2",
    "PEC": "#7f7f7f",
    "VSMC": "#bcbd22",
    "B Cells": "#17becf",
    "DTL_ATL": "#1f77b4",
    "inflammatory Monocytes": "#ff7f0e",
    "MC1": "#2ca02c",
    "EC_DVR": "#d62728",
    "M2 Macrophages": "#9467bd",
    "Neutrophil": "#8c564b",
    "Baso/Mast": "#e377c2"
}

# Example usage
print(cell_colors["EC_Peritub"])  # Outputs: #1f77b4

sc.pl.scatter(
    adata_subset,
    x="CenterX_global_px",
    y="CenterY_global_px",
    color="fov",
    size=1,
    legend_loc = 'on data', legend_fontsize=6,
    legend_fontoutline=2
)

print(adata_subset.obs["fov"])

# Commented out IPython magic to ensure Python compatibility.
# %config InlineBackend.figure_format='retina'
plt.style.use('dark_background')

sq.pl.spatial_segment(
    adata_subset,
    color="combined_neighborhood",
    library_key="fov",
    library_id= ['1'],
    seg_cell_id="cell_ID",
    seg_outline=True,
    img=False,
    #scalebar_dx=0.12,
    scalebar_kwargs={"scale_loc": "bottom", "location": "upper right"},
    legend_fontsize='xx-small'
)

# Commented out IPython magic to ensure Python compatibility.
# %config InlineBackend.figure_format='retina'
plt.style.use('dark_background')

sq.pl.spatial_segment(
    adata_subset,
    color="PT_neighborhood_cluster",
    library_key="fov",
    library_id= ['1'],
    seg_cell_id="cell_ID",
    seg_outline=True,
    img=False,
    #scalebar_dx=0.12,
    scalebar_kwargs={"scale_loc": "bottom", "location": "upper right"},
    legend_fontsize='xx-small',
    na_color='grey'
)



# Commented out IPython magic to ensure Python compatibility.
# %config InlineBackend.figure_format='retina'
plt.style.use('dark_background')

sq.pl.spatial_segment(
    adata_subset,
    color="immune_cell_neighbor_calling",
    library_key="fov",
    library_id= ['12'],
    seg_cell_id="cell_ID",
    seg_outline=True,
    img=False,
    scalebar_dx=0.12,
    scalebar_kwargs={"scale_loc": "bottom", "location": "upper right"},
    legend_fontsize='xx-small'
)

# Commented out IPython magic to ensure Python compatibility.
# %config InlineBackend.figure_format='retina'
plt.style.use('dark_background')

sq.pl.spatial_segment(
    adata_subset,
    color="immune_cell_neighbor_calling",
    library_key="fov",
    library_id= ['22'],
    seg_cell_id="cell_ID",
    seg_outline=True,
    img=False,
    #scalebar_dx=0.12,
    scalebar_kwargs={"scale_loc": "bottom", "location": "upper right"},
    legend_fontsize='xx-small'
)

# Commented out IPython magic to ensure Python compatibility.
# %config InlineBackend.figure_format='retina'
plt.style.use('dark_background')

sq.pl.spatial_segment(
    adata_subset,
    color="immune_cell_neighbor_calling",
    library_key="fov",
    library_id= ['23'],
    seg_cell_id="cell_ID",
    seg_outline=True,
    img=False,
    #scalebar_dx=0.12,
    scalebar_kwargs={"scale_loc": "bottom", "location": "upper right"},
    legend_fontsize='xx-small'
)

sc.pl.scatter(
    adata_subset,
    x="CenterX_global_px",
    y="CenterY_global_px",
    color="PT_neighborhood_cluster",
    size=2, legend_fontsize=6,
    legend_fontoutline=2
)