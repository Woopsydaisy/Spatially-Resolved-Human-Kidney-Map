# -*- coding: utf-8 -*-
"""Supplemental for Fig 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bN5L3Zk6uK-pab3yblgV_L8W92lJwb3Z
"""

!pip install --quiet scanpy
!pip install --quiet leidenalg

import csv
import anndata as ad
import gzip
import os
import scipy.io
import scanpy as sc
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from google.colab import drive
import leidenalg as la
from pathlib import Path

adata = sc.read_h5ad('/content/drive/MyDrive/Bernhard/Cosmx/After_Cleaning/all_Cosmx_cleaned_neighbored.h5ad')

adata_all=sc.read_h5ad('/content/drive/MyDrive/Bernhard/Cosmx/SCVI/All_Runs/allCosmx_allGenes.h5ad')

import matplotlib.pyplot as plt

# Extract nCount_RNA values
nCount_RNA_values = adata.obs['nCount_RNA']

# Create a histogram with tab10 blue color and no grid
plt.figure(figsize=(6, 6))
plt.hist(nCount_RNA_values, bins=100, color=plt.get_cmap('tab10')(0), edgecolor='black')
plt.title('Histogram of nCount_RNA')
plt.xlabel('nCount_RNA')
plt.ylabel('Frequency')
plt.xlim(0,1000)
plt.grid(False)  # Disable the grid

# Show the plot
plt.show()

import matplotlib.pyplot as plt

# Extract unique samples
unique_samples = adata.obs['sample'].unique()

# Define the number of subplots
num_samples = len(unique_samples)

# Create a figure with subplots
fig, axes = plt.subplots(num_samples, 1, figsize=(6, 6 * num_samples), sharex=True)

# Ensure axes is iterable
if num_samples == 1:
    axes = [axes]

# Iterate through each sample and plot the histogram
for i, sample in enumerate(unique_samples):
    sample_data = adata.obs[adata.obs['sample'] == sample]['nCount_RNA']
    axes[i].hist(sample_data, bins=50, color=plt.get_cmap('tab10')(0), edgecolor='black')
    axes[i].set_title(f'Histogram of nCount_RNA for {sample}')
    axes[i].set_xlabel('nCount_RNA')
    axes[i].set_ylabel('Frequency')
    axes[i].set_xlim(0, 1000)
    axes[i].grid(False)


plt.savefig('nCount_RNA_histograms.png')

# Show the figure
plt.show()

import matplotlib.pyplot as plt

# Extract unique samples
unique_samples = adata.obs['sample'].unique()

# Define the number of rows based on the number of samples
num_samples = len(unique_samples)

# Create a figure with subplots, 2 columns (for nCount_RNA and nFeature_RNA)
fig, axes = plt.subplots(num_samples, 2, figsize=(12, 6 * num_samples), sharex='col')

# Ensure axes is iterable
if num_samples == 1:
    axes = [axes]

# Iterate through each sample and plot the histograms
for i, sample in enumerate(unique_samples):
    sample_data_count = adata.obs[adata.obs['sample'] == sample]['nCount_RNA']
    sample_data_feature = adata.obs[adata.obs['sample'] == sample]['nFeature_RNA']

    # Plot nCount_RNA histogram
    axes[i, 0].hist(sample_data_count, bins=20, color=plt.get_cmap('tab10')(0), edgecolor='black')
    axes[i, 0].set_title(f'nCount_RNA for {sample}')
    axes[i, 0].set_ylabel('Frequency')
    axes[i, 0].set_xlim(0, 1000)
    axes[i, 0].grid(False)

    # Plot nFeature_RNA histogram
    axes[i, 1].hist(sample_data_feature, bins=20, color=plt.get_cmap('tab10')(1), edgecolor='black')
    axes[i, 1].set_title(f'nFeature_RNA for {sample}')
    axes[i, 1].set_xlim(0, 400)
    axes[i, 1].grid(False)

# Set xlabel for the bottom plots only
axes[-1, 0].set_xlabel('nCount_RNA')
axes[-1, 1].set_xlabel('nFeature_RNA')

# Adjust layout
plt.tight_layout()

# Save the figure with 900 DPI
plt.savefig('nCount_nFeature_RNA_histograms.png')

# Show the figure
plt.show()

import matplotlib.pyplot as plt

# Extract unique samples
unique_samples = adata.obs['sample'].unique()

# Define the number of rows, with 2 sample rows per figure row, each containing 2 plots (for nCount_RNA and nFeature_RNA)
num_rows = (len(unique_samples) + 1) // 2  # Ensures an extra row if odd number of samples

# Create a figure with subplots, 4 columns per row for nCount_RNA and nFeature_RNA for two samples per figure row
fig, axes = plt.subplots(num_rows, 4, figsize=(24, 6 * num_rows), sharex='col', sharey='row')

# Ensure axes is iterable in case of a single row
if num_rows == 1:
    axes = [axes]

# Iterate through each sample and plot the histograms
for i, sample in enumerate(unique_samples):
    row = i // 2  # Determine which row in the figure
    col = (i % 2) * 2  # Determine start column in the figure, 0 or 2

    # Indices for subplots
    ax1 = axes[row][col]      # nCount_RNA plot position
    ax2 = axes[row][col + 1]  # nFeature_RNA plot position

    # Plot nCount_RNA histogram
    sample_data_count = adata.obs[adata.obs['sample'] == sample]['nCount_RNA']
    ax1.hist(sample_data_count, bins=20, color=plt.get_cmap('tab10')(0), edgecolor='black')
    ax1.set_title(f'nCount_RNA for {sample}')
    ax1.set_ylabel('Frequency')
    ax1.set_xlabel('nCount_RNA')
    ax1.set_xlim(0, 1000)
    ax1.grid(False)

    # Plot nFeature_RNA histogram
    sample_data_feature = adata.obs[adata.obs['sample'] == sample]['nFeature_RNA']
    ax2.hist(sample_data_feature, bins=20, color=plt.get_cmap('tab10')(1), edgecolor='black')
    ax2.set_title(f'nFeature_RNA for {sample}')
    ax2.set_xlabel('nFeature_RNA')
    ax2.set_xlim(0, 400)
    ax2.grid(False)

# Adjust layout
plt.tight_layout()

# Save the figure with 900 DPI
plt.savefig('nCount_nFeature_RNA_histograms_grouped.png', dpi=450)

# Show the figure
plt.show()

import matplotlib.pyplot as plt

# Extract unique samples
unique_samples = adata.obs['sample'].unique()

# Define the number of rows, with 3 sample pairs per figure row
num_rows = (len(unique_samples) + 2) // 3  # Ensures an extra row if the number of samples is not a multiple of 3

# Create a figure with subplots, 6 columns per row for nCount_RNA and nFeature_RNA for three samples per figure row
fig, axes = plt.subplots(num_rows, 6, figsize=(18, 3 * num_rows), sharex='col', sharey='row')

# Ensure axes is iterable in case of a single row
if num_rows == 1:
    axes = [axes]

# Flatten the axes array for easy indexing if it's multidimensional
if num_rows > 1:
    axes = axes.flatten()

# Iterate through each sample and plot the histograms
for i, sample in enumerate(unique_samples):
    row = i // 3  # Determine which row in the figure
    col = (i % 3) * 2  # Determine start column in the figure, 0, 2, or 4

    # Indices for subplots
    ax1 = axes[row * 6 + col]      # nCount_RNA plot position
    ax2 = axes[row * 6 + col + 1]  # nFeature_RNA plot position

    # Plot nCount_RNA histogram
    sample_data_count = adata.obs[adata.obs['sample'] == sample]['nCount_RNA']
    ax1.hist(sample_data_count, bins=30, color=plt.get_cmap('tab10')(0), edgecolor='black')
    ax1.set_title(f'nCount_RNA for {sample}')
    ax1.set_ylabel('Number of Cells')
    ax1.set_xlabel('nCount_RNA')
    ax1.set_xlim(0, 1000)
    ax1.grid(False)

    # Plot nFeature_RNA histogram
    sample_data_feature = adata.obs[adata.obs['sample'] == sample]['nFeature_RNA']
    ax2.hist(sample_data_feature, bins=30, color=plt.get_cmap('tab10')(1), edgecolor='black')
    ax2.set_title(f'nFeature_RNA for {sample}')
    ax2.set_xlabel('nFeature_RNA')
    ax2.set_xlim(0, 400)
    ax2.grid(False)

# Adjust layout
plt.tight_layout()

# Save the figure with 900 DPI
plt.savefig('nCount_nFeature_RNA_histograms_grouped.png', dpi=450)

# Show the figure
plt.show()

import matplotlib.pyplot as plt

# Extract unique samples
unique_samples = adata.obs['sample'].unique()

# Define the number of rows, with 3 sample pairs per figure row
num_rows = (len(unique_samples) + 2) // 3  # Ensures an extra row if the number of samples is not a multiple of 3

# Create a figure with subplots, 6 columns per row for nCount_RNA and nFeature_RNA for three samples per figure row
fig, axes = plt.subplots(num_rows, 6, figsize=(18, 3 * num_rows))

# Ensure axes is iterable in case of a single row
if num_rows == 1:
    axes = [axes]

# Flatten the axes array for easy indexing if it's multidimensional
if num_rows > 1:
    axes = axes.flatten()

# Iterate through each sample and plot the histograms
for i, sample in enumerate(unique_samples):
    row = i // 3  # Determine which row in the figure
    col = (i % 3) * 2  # Determine start column in the figure, 0, 2, or 4

    # Indices for subplots
    ax1 = axes[row * 6 + col]      # nCount_RNA plot position
    ax2 = axes[row * 6 + col + 1]  # nFeature_RNA plot position

    # Plot nCount_RNA histogram
    sample_data_count = adata.obs[adata.obs['sample'] == sample]['nCount_RNA']
    ax1.hist(sample_data_count, bins=30, color=plt.get_cmap('tab10')(0), edgecolor='black')
    ax1.set_title(f'Counts per Cell {sample}')
    ax1.set_ylabel('Number of Cells')
    ax1.set_xlabel('Counts per Cell')
    ax1.set_xlim(0, 1000)
    ax1.grid(False)

    # Plot nFeature_RNA histogram
    sample_data_feature = adata.obs[adata.obs['sample'] == sample]['nFeature_RNA']
    ax2.hist(sample_data_feature, bins=30, color=plt.get_cmap('tab10')(1), edgecolor='black')
    ax2.set_title(f'Features per Cell {sample}')
    ax2.set_ylabel('Number of Cells')
    ax2.set_xlabel('Features per Cell')
    ax2.set_xlim(0, 400)
    ax2.grid(False)

# Adjust layout
plt.tight_layout()

# Save the figure with 900 DPI
plt.savefig('nCount_nFeature_RNA_histograms_grouped.png', dpi=450)

# Show the figure
plt.show()

sc.pl.umap(adata, color = "sample")

import matplotlib.pyplot as plt
import scanpy as sc

# Extract unique samples
unique_samples = adata.obs['sample'].unique()

# Define the number of rows, each row having 4 UMAP plots
num_rows = (len(unique_samples) + 3) // 4  # Ensures an extra row if number of samples is not multiple of 4

# Create a figure with subplots
fig, axes = plt.subplots(num_rows, 4, figsize=(20, 4 * num_rows))  # Adjust subplot size as needed

# Ensure axes is iterable in case of a single row or column
if num_rows == 1:
    axes = axes[np.newaxis, :]  # Adds an extra dimension to make indexing consistent
if len(unique_samples) < 4 and num_rows > 1:
    axes = axes[:, np.newaxis]

# Flatten axes for easier handling
axes = axes.flatten()

# Iterate through each sample and plot the UMAP
for i, sample in enumerate(unique_samples):
    ax = axes[i]
    # Subset the data to include only the current sample
    sc.pl.umap(adata[adata.obs['sample'] == sample, :], color='sample', legend_loc='none',show=False, ax=ax, title=f'{sample}', frameon=False)

# Hide any unused subplots
for j in range(i + 1, len(axes)):
    axes[j].axis('off')

# Adjust layout and spacing
plt.tight_layout()

# Save the figure
plt.savefig('UMAP_per_sample.png', dpi=450)  # You can adjust the DPI as needed

# Show the figure
plt.show()

adata = sc.read_h5ad('/content/drive/MyDrive/Bernhard/Cosmx/SCVI/All_Runs/adult_CosMx_postSCVI_round4_Scanvi_fine_with_garbage_5_percent.h5ad')

sn_adata=adata[adata.obs['tech']=="SN_SEQ"]
sn_adata

plt.figure(figsize=(5, 3))
ax = sc.pl.violin(sn_adata, keys='nCount_RNA', groupby='sample', size=2, linewidth=1, show=False, stripplot=False)

# Rotate the x-axis labels by 90 degrees
plt.xticks(rotation=90)
ax.set_ylabel('Counts per Cell')
ax.set_xlabel('')
# Adjust layout to fit rotated labels
plt.tight_layout()

# Save the figure if needed
plt.savefig('violin_plot_nCount_RNA_by_sample_SN.png', dpi=450)

# Show the plot
plt.show()

plt.figure(figsize=(5, 3))
ax = sc.pl.violin(sn_adata, keys='nFeature_RNA', groupby='sample', size=2, linewidth=1, show=False,stripplot=False)

# Rotate the x-axis labels by 90 degrees
plt.xticks(rotation=90)
ax.set_ylabel('Features per Cell')
ax.set_xlabel('')
# Adjust layout to fit rotated labels
plt.tight_layout()

# Save the figure if needed
plt.savefig('violin_plot_nFeature_RNA_by_sample_SN.png', dpi=450)

# Show the plot
plt.show()

plt.figure(figsize=(5, 3))
ax = sc.pl.violin(sn_adata, keys='percent_mt', groupby='sample', size=2, linewidth=1, show=False,stripplot=False)

# Rotate the x-axis labels by 90 degrees
plt.xticks(rotation=90)
ax.set_ylabel('percent mito')
ax.set_xlabel('')
# Adjust layout to fit rotated labels
plt.tight_layout()

# Save the figure if needed
plt.savefig('violin_plot_percent_mt_by_sample_SN.png', dpi=450)

# Show the plot
plt.show()

adata_test=sc.read_h5ad('/content/drive/MyDrive/Bernhard/Cosmx/After_Cleaning/neighbors_as_genes_all_cosmx_scvi_v1.h5ad')

sc.pl.umap(adata_test, color = "leiden_scVI_0_5")

sc.pl.umap(adata_test, color = "sample")

adata_test

sc.pl.umap(adata_test, color = "annotation_post_scanvi70_broad")

sc.pl.umap(adata_test, color = "total_neighbors_200")

podo_adata_test=adata_test[adata_test.obs['annotation_post_scanvi70_broad']=='Podo']
sc.pl.umap(podo_adata_test, color = "sample")

pt_adata_test=adata_test[adata_test.obs['annotation_post_scanvi70_broad']=='PT']
sc.pl.umap(pt_adata_test, color = "sample")

pt_adata_test=adata_test[adata_test.obs['annotation_post_scanvi70_broad']=='Immune']
sc.pl.umap(pt_adata_test, color = "annotation_post_scanvi70_broad")

adata_all

adata_all.X=adata_all.layers['counts'].copy()
sc.pp.log1p(adata_all)
sc.tl.rank_genes_groups(adata_all, groupby='annotation_post_scanvi70_broad', method='wilcoxon', pts = True)
sc.pl.rank_genes_groups(adata_all, n_genes=25, sharey=False)

pops=['DTL_ATL', 'iPT']
mask=adata_all.obs['annotation_post_scanvi70_broad'].isin(pops)
subset=adata_all[mask]
subset

subset.X=subset.layers['counts'].copy()
sc.pp.log1p(subset)
sc.tl.rank_genes_groups(subset, groupby='annotation_post_scanvi70_broad', method='wilcoxon', pts = True)
sc.pl.rank_genes_groups(subset, n_genes=25, sharey=False)

adata_all.X=adata_all.layers['counts'].copy()
sc.pp.log1p(adata_all)
sc.tl.rank_genes_groups(adata_all, groupby='annotation_post_scanvi70_broad',reference='iPT', method='wilcoxon', pts = True)
sc.pl.rank_genes_groups(adata_all, n_genes=25, sharey=False)

import pandas as pd
from scipy.sparse import issparse
# Assuming 'adata' is your AnnData object
markers = ['CALB1','SPP1','SLC12A3','GSTP1','PECAM1','TM4SF1', 'KLF2','PLVAP','ENG', 'IGFBP5', 'TGFBR2',  'COL1A1', 'COL1A2', 'SLC26A7',
           'KRT7','SLC4A9', 'HLA-DRB', 'HLA-DRA', 'CXCR4', 'AQP2', 'AQP3', 'GATA3','DUSP1', 'IGFBP7',  'ACSM2B', 'LRP2', 'CUBN',
           'NPHS2', 'VEGFA','SPOCK2', 'UMOD', 'SLC12A1', 'TAGLN', 'ACTA2','NOTCH3', 'CRYAB','TPM1', 'IL32', 'S100A6', 'TACSTD2',  'IGFBP5']

# Ensure markers list only includes valid gene names
markers = [gene for gene in markers if gene in adata_all.var_names]

# Subset the .X matrix for the markers and convert to a DataFrame
gene_expression_df_unimputed = pd.DataFrame(
    adata_all[:, markers].X.toarray() if issparse(adata_all.X) else adata_all[:, markers].X,
    index=adata_all.obs_names,
    columns=markers
)

gene_expression_df_unimputed['annotation'] = adata_all.obs['annotation_post_scanvi70_broad'].values
mean_expression_per_cluster_unimputed = gene_expression_df_unimputed.groupby('annotation').mean()
#print(mean_expression_per_cluster_unimputed)

from sklearn.preprocessing import MinMaxScaler

# Create a MinMaxScaler object
scaler = MinMaxScaler()

# Scale each column individually
gene_expression_scaled_unimputed = scaler.fit_transform(mean_expression_per_cluster_unimputed)

# Convert the scaled array back to a DataFrame
gene_expression_scaled_df_unimputed = pd.DataFrame(gene_expression_scaled_unimputed, index=mean_expression_per_cluster_unimputed.index, columns=mean_expression_per_cluster_unimputed.columns)

# Display the first few rows of the scaled dataframe
#print(gene_expression_scaled_df_unimputed)

# Assuming 'gene_expression_scaled_df_unimputed' is your DataFrame and it's correctly formatted
# The '.T' is transposing the DataFrame, which is typical in heatmaps for better visualization of genes on one axis

plt.figure(figsize=(20, 10))  # Adjust the figure size as needed
heatmap = sns.heatmap(gene_expression_scaled_df_unimputed, cmap='plasma', vmax=1, cbar_kws={"shrink": .3})

# Adjust the size of the colorbar
heatmap.collections[0].colorbar.ax.set_ylabel('Expression level')
heatmap.collections[0].colorbar.ax.set_xlabel('')
# Removing the tick marks as requested (optional)
plt.tick_params(axis='both', which='both', length=0)  # Ensures no tick marks on both x and y axes

# Save the figure
plt.savefig('suppl_heatmap_all_cosmx.png', dpi=450, bbox_inches='tight')

# Show the plot
plt.show()

adata=sc.read_h5ad('/content/drive/MyDrive/Bernhard/Cosmx/After_Cleaning/neighbors_as_genes_all_cosmx_scvi_v1.h5ad')

sc.pl.umap(adata, color="sample")

adata_v1=sc.read_h5ad('/content/drive/MyDrive/Bernhard/Cosmx/After_Cleaning/neighbors_as_genes_subset_cosmx_annotated_scvi_v1_scanvi_v1.h5ad')

sc.pl.umap(adata_v1, color="sample")

sc.pl.umap(adata_v1, color="cluster_labels_annotated")

sc.pl.umap(adata_v1, color="leiden_scanvi_0_1")

adata_v1.obs['leiden_scanvi_0_1'].value_counts()

adata=sc.read_h5ad('/content/drive/MyDrive/Bernhard/Cosmx/After_Cleaning/neighbors_as_genes_subset_cosmx_annotated_scvi_v1_scanvi_v2.h5ad')

sc.pl.umap(adata, color="sample")

adata

sc.pl.umap(adata, color="cluster_labels_annotated_scvi")

sc.pl.umap(adata, color="leiden_scanvi_0_1")

adata.obs['leiden_scanvi_0_1'].value_counts()

adata