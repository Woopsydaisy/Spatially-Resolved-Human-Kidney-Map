# -*- coding: utf-8 -*-
"""PyGAM Fig 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dd4lQS729UMK4qlrINVmd3WrDnmUv2TL
"""

!pip install --quiet scanpy
!pip install --quiet leidenalg
!pip install --quiet pygam

import csv
import anndata as ad
import gzip
import os
import scipy.io
import scanpy as sc
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from google.colab import drive
import leidenalg as la
from pathlib import Path
from pygam import LinearGAM, s
from pygam import LogisticGAM, s

adata = sc.read_h5ad('/content/drive/MyDrive/Bernhard/Cosmx/After_Cleaning/all_Cosmx_cleaned_neighbored.h5ad')

subset_adata=adata[adata.obs['sample']=='Pediatric1']

subset_adata.obs['fov']=subset_adata.obs['fov'].astype(int)

# fov_include is already a list
fov_include = [36, 37, 39, 40, 41, 44, 45, 46, 51, 52, 53, 60, 61, 62, 70, 71, 72, 81, 82, 83, 92, 93, 94, 103, 104, 105, 114, 115, 116, 125, 126,
               127, 136, 137, 138, 147, 148, 149, 157, 158, 159, 168, 169, 170, 179, 180, 181, 187, 188, 189, 197, 198, 199, 207, 208, 209, 217,
               218, 219, 226, 227, 228, 235, 236, 237, 245, 246, 247]

# Filter the data to include only FOVs in fov_include
filtered_data = subset_adata[subset_adata.obs['fov'].isin(fov_include)]

filtered_data.X = filtered_data.layers["counts"].copy()

filtered_data

sc.pl.scatter(
    filtered_data,
    x="CenterX_global_px",
    y="CenterY_global_px",
    color="annotation_post_scanvi70_broad",
    size=3,
    color_map='plasma'
)

filtered_data.obs['annotation_post_scanvi70_broad'].value_counts()

sc.pp.normalize_total(filtered_data, target_sum=1e4)
sc.pp.log1p(filtered_data)

dense_matrix = filtered_data.X.toarray()

# Create a DataFrame from the dense matrix
df = pd.DataFrame(dense_matrix, index=filtered_data.obs.index, columns=filtered_data.var.index)
#df

filtered_Y_values = filtered_data.obs['CenterY_global_px']

# Align the indices
filtered_Y_values.index = df.index

df['Y_values'] = filtered_Y_values
#df

df['Y_values_scaled'] = (df['Y_values'] - df['Y_values'].min()) / (df['Y_values'].max() - df['Y_values'].min())

# Check the updated DataFrame
#print(df)

df['Y_values_scaled']=df['Y_values_scaled']*-1
df['Y_values_scaled']=df['Y_values_scaled']+1

annotation = filtered_data.obs['annotation_post_scanvi70_broad']

# Align the indices
annotation.index = df.index

df['annotation_fine'] = annotation

annotation_coarse = filtered_data.obs['annotation_post_scanvi70_coarse']

# Align the indices
annotation_coarse.index = df.index

df['annotation_coarse'] = annotation_coarse
df

df=df.drop('Y_values', axis=1)

#df

"""Lets try PT"""

filtered_df_pt=df[df['annotation_fine']=='PT']
filtered_df_pt=filtered_df_pt.drop(['annotation_fine', 'annotation_coarse'], axis=1)
#filtered_df_pt

# Calculate the 5th and 95th percentiles
lower_threshold = filtered_df_pt['Y_values_scaled'].quantile(0.05)
upper_threshold = filtered_df_pt['Y_values_scaled'].quantile(0.95)
# Exclude the top 5% and bottom 5% outliers
filtered_df = filtered_df_pt[(filtered_df_pt['Y_values_scaled'] >= lower_threshold) & (filtered_df_pt['Y_values_scaled'] <= upper_threshold)]

# Check the updated DataFrame
#print(filtered_df)

import matplotlib.pyplot as plt

# Create a boxplot
plt.boxplot(filtered_df['Y_values_scaled'])
plt.title('Boxplot of Scaled Y Values')
plt.ylabel('Scaled Y Values')
plt.show()

from pygam import LinearGAM, s
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Assuming df is your DataFrame and 'distance' is the column with distance values

# Iterate over all columns except 'distance'
for column in filtered_df.drop('Y_values_scaled', axis=1).columns:
    # Identify non-zero and zero expression rows
    non_zeros = filtered_df[filtered_df[column] > 0]
    zeros = filtered_df[filtered_df[column] == 0]
    print(len(non_zeros))
    if len(non_zeros)<2200:
      continue
    # Number of samples to match
    n_samples = min(len(non_zeros), len(zeros))

    # Randomly sample from zeros to match the number of non-zero samples
    sampled_zeros = zeros.sample(n=n_samples, random_state=42)
    sampled_non_zeros = non_zeros.sample(n=n_samples, random_state=42)

    # Concatenate the sampled data
    balanced_df = pd.concat([sampled_zeros, sampled_non_zeros])

    # Shuffle the rows to mix zero and non-zero samples
    balanced_df = balanced_df.sample(frac=1, random_state=42).reset_index(drop=True)

    # Prepare the data
    X = balanced_df[['Y_values_scaled']].values  # Independent variable (2D)
    y = balanced_df[column].values  # Continuous response variable (expression level)

    # Fit a Linear GAM with a spline term for the 'distance' feature
    gam = LinearGAM(s(0, n_splines=10)).fit(X, y)

    # Generate predictions for plotting
    X_pred = np.linspace(X.min(), X.max(), 100).reshape(-1, 1)
    y_pred = gam.predict(X_pred)

    # Plotting
    fig, ax = plt.subplots()
    plt.scatter(X.flatten(), y, alpha=0.5, color='gray', label='Balanced Data')
    plt.plot(X_pred.flatten(), y_pred, color='blue', label=f'Fit for {column}')

    # Customizing the plot
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)

    plt.xlabel('Distance')
    plt.ylabel(f'Expression of {column}')
    plt.title(f'Linear GAM Fit for {column}')
    plt.legend()
    plt.show()

from pygam import LinearGAM, s
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

include_columns = ['SLC4A4', 'GPX3']

# Iterate over all columns except 'distance'
for column in filtered_df.drop('Y_values_scaled', axis=1).columns:
    # Only process if the column is in the include list
    if column not in include_columns:
        continue
    # Identify non-zero and zero expression rows
    non_zeros = filtered_df[filtered_df[column] > 0]
    zeros = filtered_df[filtered_df[column] == 0]
    print(len(non_zeros))
    if len(non_zeros) < 800:
        continue
    # Number of samples to match
    n_samples = min(len(non_zeros), len(zeros))

    # Randomly sample from zeros to match the number of non-zero samples
    sampled_zeros = zeros.sample(n=n_samples, random_state=42)
    sampled_non_zeros = non_zeros.sample(n=n_samples, random_state=42)

    # Concatenate the sampled data
    balanced_df = pd.concat([sampled_zeros, sampled_non_zeros])

    # Shuffle the rows to mix zero and non-zero samples
    balanced_df = balanced_df.sample(frac=1, random_state=42).reset_index(drop=True)

    # Prepare the data
    X = balanced_df[['Y_values_scaled']].values  # Independent variable (2D)
    y = balanced_df[column].values  # Continuous response variable (expression level)

    # Fit a Linear GAM with a spline term for the 'distance' feature
    gam = LinearGAM(s(0, n_splines=10)).fit(X, y)

    # Generate predictions and confidence intervals for plotting
    X_pred = np.linspace(X.min(), X.max(), 100).reshape(-1, 1)
    y_pred = gam.predict(X_pred)
    y_pred_ci = gam.confidence_intervals(X_pred)  # Confidence intervals

    # Plotting
    fig, ax = plt.subplots(figsize=(2, 2))
    plt.plot(X_pred.flatten(), y_pred, color='#F3A3C5', label=f'Fit for {column}',linewidth=2)
    plt.fill_between(X_pred.flatten(), y_pred_ci[:, 0], y_pred_ci[:, 1], color='#F3A3C5', alpha=0.2)  # Confidence interval

    # Customizing the plot
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    ax.set_xticks([])
    plt.xlabel('')
    plt.ylabel(f'{column}')
    plt.xlim(0,1)
    plt.ylim(0,4.5)
    plt.title('')
    plt.savefig(f'linear_gam_fit_{column}.png', bbox_inches='tight', dpi=450)
    plt.show()

"""Podos --> doesnt work so well

Lets try Endothelium
"""

filtered_df_endo=df[df['annotation_coarse']=='Endothelium']
filtered_df_endo=filtered_df_endo.drop(['annotation_fine', 'annotation_coarse'], axis=1)
filtered_df_endo.shape

# Calculate the 5th and 95th percentiles
lower_threshold = filtered_df_endo['Y_values_scaled'].quantile(0.05)
upper_threshold = filtered_df_endo['Y_values_scaled'].quantile(0.95)
# Exclude the top 5% and bottom 5% outliers
filtered_df_endo = filtered_df_endo[(filtered_df_endo['Y_values_scaled'] >= lower_threshold) & (filtered_df_endo['Y_values_scaled'] <= upper_threshold)]

# Check the updated DataFrame
print(filtered_df_endo.shape)

import matplotlib.pyplot as plt

# Create a boxplot
plt.boxplot(filtered_df_endo['Y_values_scaled'])
plt.title('Boxplot of Scaled Y Values')
plt.ylabel('Scaled Y Values')
plt.show()

from pygam import LinearGAM, s
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Assuming df is your DataFrame and 'distance' is the column with distance values

# Iterate over all columns except 'distance'
for column in filtered_df_endo.drop('Y_values_scaled', axis=1).columns:
    # Identify non-zero and zero expression rows
    non_zeros = filtered_df_endo[filtered_df_endo[column] > 0]
    zeros = filtered_df_endo[filtered_df_endo[column] == 0]
    print(len(non_zeros))
    if len(non_zeros)<2200:
      continue
    # Number of samples to match
    n_samples = min(len(non_zeros), len(zeros))

    # Randomly sample from zeros to match the number of non-zero samples
    sampled_zeros = zeros.sample(n=n_samples, random_state=42)
    sampled_non_zeros = non_zeros.sample(n=n_samples, random_state=42)

    # Concatenate the sampled data
    balanced_df = pd.concat([sampled_zeros, sampled_non_zeros])

    # Shuffle the rows to mix zero and non-zero samples
    balanced_df = balanced_df.sample(frac=1, random_state=42).reset_index(drop=True)

    # Prepare the data
    X = balanced_df[['Y_values_scaled']].values  # Independent variable (2D)
    y = balanced_df[column].values  # Continuous response variable (expression level)

    # Fit a Linear GAM with a spline term for the 'distance' feature
    gam = LinearGAM(s(0, n_splines=10)).fit(X, y)

    # Generate predictions for plotting
    X_pred = np.linspace(X.min(), X.max(), 100).reshape(-1, 1)
    y_pred = gam.predict(X_pred)

    # Plotting
    fig, ax = plt.subplots()
    plt.scatter(X.flatten(), y, alpha=0.5, color='gray', label='Balanced Data')
    plt.plot(X_pred.flatten(), y_pred, color='blue', label=f'Fit for {column}')

    # Customizing the plot
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)

    plt.xlabel('Distance')
    plt.ylabel(f'Expression of {column}')
    plt.title(f'Linear GAM Fit for {column}')
    plt.legend()
    plt.show()

from pygam import LinearGAM, s
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

include_columns = ['TM4SF1', 'TIE1', 'SRGN', 'S100A4', 'PLVAP']

# Iterate over all columns except 'distance'
for column in filtered_df_endo.drop('Y_values_scaled', axis=1).columns:
    # Only process if the column is in the include list
    if column not in include_columns:
        continue
    # Identify non-zero and zero expression rows
    non_zeros = filtered_df_endo[filtered_df_endo[column] > 0]
    zeros = filtered_df_endo[filtered_df_endo[column] == 0]
    print(len(non_zeros))
    if len(non_zeros) < 800:
        continue
    # Number of samples to match
    n_samples = min(len(non_zeros), len(zeros))

    # Randomly sample from zeros to match the number of non-zero samples
    sampled_zeros = zeros.sample(n=n_samples, random_state=42)
    sampled_non_zeros = non_zeros.sample(n=n_samples, random_state=42)

    # Concatenate the sampled data
    balanced_df = pd.concat([sampled_zeros, sampled_non_zeros])

    # Shuffle the rows to mix zero and non-zero samples
    balanced_df = balanced_df.sample(frac=1, random_state=42).reset_index(drop=True)

    # Prepare the data
    X = balanced_df[['Y_values_scaled']].values  # Independent variable (2D)
    y = balanced_df[column].values  # Continuous response variable (expression level)

    # Fit a Linear GAM with a spline term for the 'distance' feature
    gam = LinearGAM(s(0, n_splines=10)).fit(X, y)

    # Generate predictions and confidence intervals for plotting
    X_pred = np.linspace(X.min(), X.max(), 100).reshape(-1, 1)
    y_pred = gam.predict(X_pred)
    y_pred_ci = gam.confidence_intervals(X_pred)  # Confidence intervals

    # Plotting
    fig, ax = plt.subplots(figsize=(2, 2))
    plt.plot(X_pred.flatten(), y_pred, color='#009540', label=f'Fit for {column}',linewidth=2)
    plt.fill_between(X_pred.flatten(), y_pred_ci[:, 0], y_pred_ci[:, 1], color='#009540', alpha=0.2)  # Confidence interval

    # Customizing the plot
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    ax.set_xticks([])
    plt.xlabel('')
    plt.ylabel(f'{column}')
    plt.xlim(0,1)
    plt.ylim(0,4.5)
    plt.title('')
    plt.savefig(f'linear_gam_fit_{column}.png', bbox_inches='tight', dpi=450)
    plt.show()

"""Lets try Fibro"""

filtered_df_endo=df[df['annotation_fine']=='Fibroblast']
filtered_df_endo=filtered_df_endo.drop(['annotation_fine', 'annotation_coarse'], axis=1)
filtered_df_endo.shape

# Calculate the 5th and 95th percentiles
lower_threshold = filtered_df_endo['Y_values_scaled'].quantile(0.05)
upper_threshold = filtered_df_endo['Y_values_scaled'].quantile(0.95)
# Exclude the top 5% and bottom 5% outliers
filtered_df_endo = filtered_df_endo[(filtered_df_endo['Y_values_scaled'] >= lower_threshold) & (filtered_df_endo['Y_values_scaled'] <= upper_threshold)]

# Check the updated DataFrame
print(filtered_df_endo.shape)

import matplotlib.pyplot as plt

# Create a boxplot
plt.boxplot(filtered_df_endo['Y_values_scaled'])
plt.title('Boxplot of Scaled Y Values')
plt.ylabel('Scaled Y Values')
plt.show()

from pygam import LinearGAM, s
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Assuming df is your DataFrame and 'distance' is the column with distance values

# Iterate over all columns except 'distance'
for column in filtered_df_endo.drop('Y_values_scaled', axis=1).columns:
    # Identify non-zero and zero expression rows
    non_zeros = filtered_df_endo[filtered_df_endo[column] > 0]
    zeros = filtered_df_endo[filtered_df_endo[column] == 0]
    print(len(non_zeros))
    if len(non_zeros)<2200:
      continue
    # Number of samples to match
    n_samples = min(len(non_zeros), len(zeros))

    # Randomly sample from zeros to match the number of non-zero samples
    sampled_zeros = zeros.sample(n=n_samples, random_state=42)
    sampled_non_zeros = non_zeros.sample(n=n_samples, random_state=42)

    # Concatenate the sampled data
    balanced_df = pd.concat([sampled_zeros, sampled_non_zeros])

    # Shuffle the rows to mix zero and non-zero samples
    balanced_df = balanced_df.sample(frac=1, random_state=42).reset_index(drop=True)

    # Prepare the data
    X = balanced_df[['Y_values_scaled']].values  # Independent variable (2D)
    y = balanced_df[column].values  # Continuous response variable (expression level)

    # Fit a Linear GAM with a spline term for the 'distance' feature
    gam = LinearGAM(s(0, n_splines=10)).fit(X, y)

    # Generate predictions for plotting
    X_pred = np.linspace(X.min(), X.max(), 100).reshape(-1, 1)
    y_pred = gam.predict(X_pred)

    # Plotting
    fig, ax = plt.subplots()
    plt.scatter(X.flatten(), y, alpha=0.5, color='gray', label='Balanced Data')
    plt.plot(X_pred.flatten(), y_pred, color='blue', label=f'Fit for {column}')

    # Customizing the plot
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)

    plt.xlabel('Distance')
    plt.ylabel(f'Expression of {column}')
    plt.title(f'Linear GAM Fit for {column}')
    plt.legend()
    plt.show()

from pygam import LinearGAM, s
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

include_columns = ['COL12A1', 'PDGFRA']

# Iterate over all columns except 'distance'
for column in filtered_df_endo.drop('Y_values_scaled', axis=1).columns:
    # Only process if the column is in the include list
    if column not in include_columns:
        continue
    # Identify non-zero and zero expression rows
    non_zeros = filtered_df_endo[filtered_df_endo[column] > 0]
    zeros = filtered_df_endo[filtered_df_endo[column] == 0]
    print(len(non_zeros))
    if len(non_zeros) < 800:
        continue
    # Number of samples to match
    n_samples = min(len(non_zeros), len(zeros))

    # Randomly sample from zeros to match the number of non-zero samples
    sampled_zeros = zeros.sample(n=n_samples, random_state=42)
    sampled_non_zeros = non_zeros.sample(n=n_samples, random_state=42)

    # Concatenate the sampled data
    balanced_df = pd.concat([sampled_zeros, sampled_non_zeros])

    # Shuffle the rows to mix zero and non-zero samples
    balanced_df = balanced_df.sample(frac=1, random_state=42).reset_index(drop=True)

    # Prepare the data
    X = balanced_df[['Y_values_scaled']].values  # Independent variable (2D)
    y = balanced_df[column].values  # Continuous response variable (expression level)

    # Fit a Linear GAM with a spline term for the 'distance' feature
    gam = LinearGAM(s(0, n_splines=10)).fit(X, y)

    # Generate predictions and confidence intervals for plotting
    X_pred = np.linspace(X.min(), X.max(), 100).reshape(-1, 1)
    y_pred = gam.predict(X_pred)
    y_pred_ci = gam.confidence_intervals(X_pred)  # Confidence intervals

    # Plotting
    fig, ax = plt.subplots(figsize=(2, 2))
    plt.plot(X_pred.flatten(), y_pred, color='#BA877E', label=f'Fit for {column}',linewidth=2)
    plt.fill_between(X_pred.flatten(), y_pred_ci[:, 0], y_pred_ci[:, 1], color='#BA877E', alpha=0.2)  # Confidence interval

    # Customizing the plot
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    ax.set_xticks([])
    plt.xlabel('')
    plt.ylabel(f'{column}')
    plt.xlim(0,1)
    plt.ylim(0,4.5)
    plt.title('')
    plt.savefig(f'linear_gam_fit_{column}.png', bbox_inches='tight', dpi=450)
    plt.show()

"""Lets try PC"""

filtered_df_endo=df[df['annotation_fine']=='PC']
filtered_df_endo=filtered_df_endo.drop(['annotation_fine', 'annotation_coarse'], axis=1)
filtered_df_endo.shape

# Calculate the 5th and 95th percentiles
lower_threshold = filtered_df_endo['Y_values_scaled'].quantile(0.05)
upper_threshold = filtered_df_endo['Y_values_scaled'].quantile(0.95)
# Exclude the top 5% and bottom 5% outliers
filtered_df_endo = filtered_df_endo[(filtered_df_endo['Y_values_scaled'] >= lower_threshold) & (filtered_df_endo['Y_values_scaled'] <= upper_threshold)]

# Check the updated DataFrame
print(filtered_df_endo.shape)

import matplotlib.pyplot as plt

# Create a boxplot
plt.boxplot(filtered_df_endo['Y_values_scaled'])
plt.title('Boxplot of Scaled Y Values')
plt.ylabel('Scaled Y Values')
plt.show()

from pygam import LinearGAM, s
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Assuming df is your DataFrame and 'distance' is the column with distance values

# Iterate over all columns except 'distance'
for column in filtered_df_endo.drop('Y_values_scaled', axis=1).columns:
    # Identify non-zero and zero expression rows
    non_zeros = filtered_df_endo[filtered_df_endo[column] > 0]
    zeros = filtered_df_endo[filtered_df_endo[column] == 0]
    print(len(non_zeros))
    if len(non_zeros)<400:
      continue
    # Number of samples to match
    n_samples = min(len(non_zeros), len(zeros))

    # Randomly sample from zeros to match the number of non-zero samples
    sampled_zeros = zeros.sample(n=n_samples, random_state=42)
    sampled_non_zeros = non_zeros.sample(n=n_samples, random_state=42)

    # Concatenate the sampled data
    balanced_df = pd.concat([sampled_zeros, sampled_non_zeros])

    # Shuffle the rows to mix zero and non-zero samples
    balanced_df = balanced_df.sample(frac=1, random_state=42).reset_index(drop=True)

    # Prepare the data
    X = balanced_df[['Y_values_scaled']].values  # Independent variable (2D)
    y = balanced_df[column].values  # Continuous response variable (expression level)

    # Fit a Linear GAM with a spline term for the 'distance' feature
    gam = LinearGAM(s(0, n_splines=10)).fit(X, y)

    # Generate predictions for plotting
    X_pred = np.linspace(X.min(), X.max(), 100).reshape(-1, 1)
    y_pred = gam.predict(X_pred)

    # Plotting
    fig, ax = plt.subplots()
    plt.scatter(X.flatten(), y, alpha=0.5, color='gray', label='Balanced Data')
    plt.plot(X_pred.flatten(), y_pred, color='blue', label=f'Fit for {column}')

    # Customizing the plot
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)

    plt.xlabel('Distance')
    plt.ylabel(f'Expression of {column}')
    plt.title(f'Linear GAM Fit for {column}')
    plt.legend()
    plt.show()

from pygam import LinearGAM, s
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

include_columns = ['AQP3', 'CALB1']

# Iterate over all columns except 'distance'
for column in filtered_df_endo.drop('Y_values_scaled', axis=1).columns:
    # Only process if the column is in the include list
    if column not in include_columns:
        continue
    # Identify non-zero and zero expression rows
    non_zeros = filtered_df_endo[filtered_df_endo[column] > 0]
    zeros = filtered_df_endo[filtered_df_endo[column] == 0]
    print(len(non_zeros))
    if len(non_zeros) < 400:
        continue
    # Number of samples to match
    n_samples = min(len(non_zeros), len(zeros))

    # Randomly sample from zeros to match the number of non-zero samples
    sampled_zeros = zeros.sample(n=n_samples, random_state=42)
    sampled_non_zeros = non_zeros.sample(n=n_samples, random_state=42)

    # Concatenate the sampled data
    balanced_df = pd.concat([sampled_zeros, sampled_non_zeros])

    # Shuffle the rows to mix zero and non-zero samples
    balanced_df = balanced_df.sample(frac=1, random_state=42).reset_index(drop=True)

    # Prepare the data
    X = balanced_df[['Y_values_scaled']].values  # Independent variable (2D)
    y = balanced_df[column].values  # Continuous response variable (expression level)

    # Fit a Linear GAM with a spline term for the 'distance' feature
    gam = LinearGAM(s(0, n_splines=10)).fit(X, y)

    # Generate predictions and confidence intervals for plotting
    X_pred = np.linspace(X.min(), X.max(), 100).reshape(-1, 1)
    y_pred = gam.predict(X_pred)
    y_pred_ci = gam.confidence_intervals(X_pred)  # Confidence intervals

    # Plotting
    fig, ax = plt.subplots(figsize=(2, 2))
    plt.plot(X_pred.flatten(), y_pred, color='#006AA9', label=f'Fit for {column}',linewidth=2)
    plt.fill_between(X_pred.flatten(), y_pred_ci[:, 0], y_pred_ci[:, 1], color='#006AA9', alpha=0.2)  # Confidence interval

    # Customizing the plot
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    ax.set_xticks([])
    plt.xlabel('')
    plt.ylabel(f'{column}')
    plt.xlim(0,1)
    plt.ylim(0,4.5)
    plt.title('')
    plt.savefig(f'linear_gam_fit_{column}.png', bbox_inches='tight', dpi=450)
    plt.show()



"""Lets try TAL"""

filtered_df_endo=df[df['annotation_fine']=='TAL']
filtered_df_endo=filtered_df_endo.drop(['annotation_fine', 'annotation_coarse'], axis=1)
filtered_df_endo.shape

# Calculate the 5th and 95th percentiles
lower_threshold = filtered_df_endo['Y_values_scaled'].quantile(0.05)
upper_threshold = filtered_df_endo['Y_values_scaled'].quantile(0.95)
# Exclude the top 5% and bottom 5% outliers
filtered_df_endo = filtered_df_endo[(filtered_df_endo['Y_values_scaled'] >= lower_threshold) & (filtered_df_endo['Y_values_scaled'] <= upper_threshold)]

# Check the updated DataFrame
print(filtered_df_endo.shape)

import matplotlib.pyplot as plt

# Create a boxplot
plt.boxplot(filtered_df_endo['Y_values_scaled'])
plt.title('Boxplot of Scaled Y Values')
plt.ylabel('Scaled Y Values')
plt.show()

from pygam import LinearGAM, s
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Assuming df is your DataFrame and 'distance' is the column with distance values

# Iterate over all columns except 'distance'
for column in filtered_df_endo.drop('Y_values_scaled', axis=1).columns:
    # Identify non-zero and zero expression rows
    non_zeros = filtered_df_endo[filtered_df_endo[column] > 0]
    zeros = filtered_df_endo[filtered_df_endo[column] == 0]
    print(len(non_zeros))
    if len(non_zeros)<1500:
      continue
    # Number of samples to match
    n_samples = min(len(non_zeros), len(zeros))

    # Randomly sample from zeros to match the number of non-zero samples
    sampled_zeros = zeros.sample(n=n_samples, random_state=42)
    sampled_non_zeros = non_zeros.sample(n=n_samples, random_state=42)

    # Concatenate the sampled data
    balanced_df = pd.concat([sampled_zeros, sampled_non_zeros])

    # Shuffle the rows to mix zero and non-zero samples
    balanced_df = balanced_df.sample(frac=1, random_state=42).reset_index(drop=True)

    # Prepare the data
    X = balanced_df[['Y_values_scaled']].values  # Independent variable (2D)
    y = balanced_df[column].values  # Continuous response variable (expression level)

    # Fit a Linear GAM with a spline term for the 'distance' feature
    gam = LinearGAM(s(0, n_splines=10)).fit(X, y)

    # Generate predictions for plotting
    X_pred = np.linspace(X.min(), X.max(), 100).reshape(-1, 1)
    y_pred = gam.predict(X_pred)

    # Plotting
    fig, ax = plt.subplots()
    plt.scatter(X.flatten(), y, alpha=0.5, color='gray', label='Balanced Data')
    plt.plot(X_pred.flatten(), y_pred, color='blue', label=f'Fit for {column}')

    # Customizing the plot
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)

    plt.xlabel('Distance')
    plt.ylabel(f'Expression of {column}')
    plt.title(f'Linear GAM Fit for {column}')
    plt.legend()
    plt.show()

from pygam import LinearGAM, s
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

include_columns = ['UMOD', 'IL3RA']

# Iterate over all columns except 'distance'
for column in filtered_df_endo.drop('Y_values_scaled', axis=1).columns:
    # Only process if the column is in the include list
    if column not in include_columns:
        continue
    # Identify non-zero and zero expression rows
    non_zeros = filtered_df_endo[filtered_df_endo[column] > 0]
    zeros = filtered_df_endo[filtered_df_endo[column] == 0]
    print(len(non_zeros))
    if len(non_zeros) < 400:
        continue
    # Number of samples to match
    n_samples = min(len(non_zeros), len(zeros))

    # Randomly sample from zeros to match the number of non-zero samples
    sampled_zeros = zeros.sample(n=n_samples, random_state=42)
    sampled_non_zeros = non_zeros.sample(n=n_samples, random_state=42)

    # Concatenate the sampled data
    balanced_df = pd.concat([sampled_zeros, sampled_non_zeros])

    # Shuffle the rows to mix zero and non-zero samples
    balanced_df = balanced_df.sample(frac=1, random_state=42).reset_index(drop=True)

    # Prepare the data
    X = balanced_df[['Y_values_scaled']].values  # Independent variable (2D)
    y = balanced_df[column].values  # Continuous response variable (expression level)

    # Fit a Linear GAM with a spline term for the 'distance' feature
    gam = LinearGAM(s(0, n_splines=10)).fit(X, y)

    # Generate predictions and confidence intervals for plotting
    X_pred = np.linspace(X.min(), X.max(), 100).reshape(-1, 1)
    y_pred = gam.predict(X_pred)
    y_pred_ci = gam.confidence_intervals(X_pred)  # Confidence intervals

    # Plotting
    fig, ax = plt.subplots(figsize=(2, 2))
    plt.plot(X_pred.flatten(), y_pred, color='#009FB8', label=f'Fit for {column}',linewidth=2)
    plt.fill_between(X_pred.flatten(), y_pred_ci[:, 0], y_pred_ci[:, 1], color='#009FB8', alpha=0.2)  # Confidence interval

    # Customizing the plot
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    ax.set_xticks([])
    plt.xlabel('')
    plt.ylabel(f'{column}')
    plt.xlim(0,1)
    plt.ylim(0,4.5)
    plt.title('')
    plt.savefig(f'linear_gam_fit_{column}.png', bbox_inches='tight', dpi=450)
    plt.show()

from pygam import LinearGAM, s
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

include_columns = ['UMOD']

# Iterate over all columns except 'distance'
for column in filtered_df_endo.drop('Y_values_scaled', axis=1).columns:
    # Only process if the column is in the include list
    if column not in include_columns:
        continue
    # Identify non-zero and zero expression rows
    non_zeros = filtered_df_endo[filtered_df_endo[column] > 0]
    zeros = filtered_df_endo[filtered_df_endo[column] == 0]
    print(len(non_zeros))
    if len(non_zeros) < 400:
        continue
    # Number of samples to match
    n_samples = min(len(non_zeros), len(zeros))

    # Randomly sample from zeros to match the number of non-zero samples
    sampled_zeros = zeros.sample(n=n_samples, random_state=42)
    sampled_non_zeros = non_zeros.sample(n=n_samples, random_state=42)

    # Concatenate the sampled data
    balanced_df = pd.concat([sampled_zeros, sampled_non_zeros])

    # Shuffle the rows to mix zero and non-zero samples
    balanced_df = balanced_df.sample(frac=1, random_state=42).reset_index(drop=True)

    # Prepare the data
    X = balanced_df[['Y_values_scaled']].values  # Independent variable (2D)
    y = balanced_df[column].values  # Continuous response variable (expression level)

    # Fit a Linear GAM with a spline term for the 'distance' feature
    gam = LinearGAM(s(0, n_splines=10)).fit(X, y)

    # Generate predictions and confidence intervals for plotting
    X_pred = np.linspace(X.min(), X.max(), 100).reshape(-1, 1)
    y_pred = gam.predict(X_pred)
    y_pred_ci = gam.confidence_intervals(X_pred)  # Confidence intervals

    # Plotting
    fig, ax = plt.subplots(figsize=(2, 2))
    plt.plot(X_pred.flatten(), y_pred, color='#009FB8', label=f'Fit for {column}',linewidth=2)
    plt.fill_between(X_pred.flatten(), y_pred_ci[:, 0], y_pred_ci[:, 1], color='#009FB8', alpha=0.2)  # Confidence interval

    # Customizing the plot
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    ax.set_xticks([])
    plt.xlabel('')
    plt.ylabel(f'{column}')
    plt.xlim(0,1)
    plt.ylim(0,7)
    plt.title('')
    plt.savefig(f'linear_gam_fit_{column}.png', bbox_inches='tight', dpi=450)
    plt.show()

"""now for the celltypes with a logistic GAM"""

df['annotation_coarse'].value_counts()

log_df=df.copy()

df['annotation_pt'] = df['annotation_fine'].apply(lambda x: 1 if x == 'PT' else 0)
df['annotation_endo'] = df['annotation_coarse'].apply(lambda x: 1 if x == 'Endothelium' else 0)
df['annotation_fibro'] = df['annotation_fine'].apply(lambda x: 1 if x == 'Fibroblast' else 0)
df['annotation_tal'] = df['annotation_fine'].apply(lambda x: 1 if x == 'TAL' else 0)
df['annotation_pc'] = df['annotation_fine'].apply(lambda x: 1 if x == 'PC' else 0)
df['annotation_glom'] = df['annotation_fine'].apply(lambda x: 1 if (x == 'Podo') or (x == 'EC_glom') or (x == 'MC1')or (x == 'PEC') else 0)
df['annotation_icb'] = df['annotation_fine'].apply(lambda x: 1 if x == 'IC B' else 0)
df['annotation_ica'] = df['annotation_fine'].apply(lambda x: 1 if x == 'IC A' else 0)
df['annotation_cnt'] = df['annotation_fine'].apply(lambda x: 1 if x == 'CNT' else 0)
df['annotation_dct'] = df['annotation_fine'].apply(lambda x: 1 if x == 'DCT' else 0)
df['annotation_immune'] = df['annotation_fine'].apply(lambda x: 1 if x == 'Immune' else 0)

df

from pygam import LogisticGAM, s
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

columns_to_plot = {
    'annotation_pt': '#F3A3C5',  # Example color for PT
    'annotation_endo': '#009540',  # Example color for Endothelium
    'annotation_fibro': '#BA877E',  # Example color for Fibroblast
    'annotation_tal': '#009FB8',
    'annotation_pc': '#006AA9',
    'annotation_glom': '#D62729',
    'annotation_icb': '#8F67A9',  # Example color for IC B
    'annotation_ica': '#F29697',  # Example color for IC A
    'annotation_cnt': '#AEC7E7',  # Example color for CNT
    'annotation_dct': '#F07E20',  # Example color for DCT
    'annotation_immune': '#C5B0D5'  # Example color for Immune
}
# Iterate over columns and colors
for column, color in columns_to_plot.items():
    # Only process if the column is in the DataFrame
    if column not in df.columns:
        continue
    print(column)
    # Identify non-zero and zero expression rows
    non_zeros = df[df[column] > 0]
    zeros = df[df[column] == 0]

    # Number of samples to match
    n_samples = min(len(non_zeros), len(zeros))

    # Randomly sample from zeros to match the number of non-zero samples
    sampled_zeros = zeros.sample(n=n_samples, random_state=42)
    sampled_non_zeros = non_zeros.sample(n=n_samples, random_state=42)

    # Concatenate the sampled data
    balanced_df = pd.concat([sampled_zeros, sampled_non_zeros])

    # Shuffle the rows to mix zero and non-zero samples
    balanced_df = balanced_df.sample(frac=1, random_state=42).reset_index(drop=True)

    # Prepare the data
    X = balanced_df[['Y_values_scaled']].values  # Independent variable (2D)
    y = balanced_df[column].values  # Binary response variable (expression level)

    # Fit a Logistic GAM with a spline term for the 'distance' feature
    gam = LogisticGAM(s(0, n_splines=10)).fit(X, y)

    # Generate predictions for plotting
    X_pred = np.linspace(X.min(), X.max(), 100).reshape(-1, 1)
    y_pred = gam.predict_proba(X_pred)
    y_pred_ci = gam.confidence_intervals(X_pred)  # Confidence intervals

    # Plotting
    fig, ax = plt.subplots(figsize=(2, 2))  # Adjust size as needed
    plt.plot(X_pred.flatten(), y_pred, color=color, label=f'Fit for {column}', linewidth=2)
    plt.fill_between(X_pred.flatten(), y_pred_ci[:, 0], y_pred_ci[:, 1], color=color, alpha=0.2)  # Confidence interval

    # Customizing the plot
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    ax.set_xticks([])
    plt.xlabel('')
    plt.ylabel(f'{column}')
    plt.xlim(0, 1)
    plt.ylim(0, 1)
    plt.title('')
    plt.legend().set_visible(False)  # Remove legend box
    plt.savefig(f'log_gam_fit_{column}.png', bbox_inches='tight', dpi=450)
    plt.show()

from pygam import LogisticGAM, s
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Assuming df is your DataFrame and 'distance' is a column with distance values
# Also assuming each other column is binary (0 or 1) indicating the presence or absence of an expression
columns_to_plot=['annotation_pc', 'annotation_tal','annotation_fibro','annotation_endo','annotation_pt']

# Iterate over all columns except 'distance'
for column in columns_to_plot:
    # Identify non-zero and zero expression rows
    non_zeros = df[df[column] != 0]
    zeros = df[df[column] == 0]

    # Number of samples to match
    n_samples = min(len(non_zeros), len(zeros))
    print(f'Subsampled {n_samples} samples for {column}.')  # Printing the subsample size

    # Randomly sample from zeros to match the number of non-zero samples
    sampled_zeros = zeros.sample(n=n_samples, random_state=42)
    sampled_non_zeros = non_zeros.sample(n=n_samples, random_state=42)

    # Concatenate the sampled data
    balanced_df = pd.concat([sampled_zeros, sampled_non_zeros])

    # Shuffle the rows to mix zero and non-zero samples
    balanced_df = balanced_df.sample(frac=1, random_state=42).reset_index(drop=True)

    # Prepare the data
    X = balanced_df[['Y_values_scaled']].values  # Independent variable (2D)
    y = balanced_df[column].values  # Binary response variable (expression level)

    # Fit a Logistic GAM with a spline term for the 'distance' feature
    gam = LogisticGAM(s(0, n_splines=10)).fit(X, y)

    # Generate predictions for plotting
    X_pred = np.linspace(X.min(), X.max(), 100).reshape(-1, 1)
    y_pred = gam.predict_proba(X_pred)

    # Plotting
    fig, ax = plt.subplots()
    plt.scatter(X.flatten(), y, alpha=0.5, color='gray', label='Balanced Data')
    plt.plot(X_pred.flatten(), y_pred, color='blue', label=f'Fit for {column}')

    # Customizing the plot
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)

    plt.xlabel('Distance')
    plt.ylabel(f'Probability of Presence for {column}')
    plt.title(f'Logistic GAM Fit for {column}')
    plt.show()

from pygam import LogisticGAM, s
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

columns_to_plot=[ 'annotation_tal']

# Iterate over all columns except 'distance'
for column in columns_to_plot:
    # Only process if the column is in the include list
    # Identify non-zero and zero expression rows
    non_zeros = df[df[column] > 0]
    zeros = df[df[column] == 0]
    # Number of samples to match
    n_samples = min(len(non_zeros), len(zeros))

    # Randomly sample from zeros to match the number of non-zero samples
    sampled_zeros = zeros.sample(n=n_samples, random_state=42)
    sampled_non_zeros = non_zeros.sample(n=n_samples, random_state=42)

    # Concatenate the sampled data
    balanced_df = pd.concat([sampled_zeros, sampled_non_zeros])

    # Shuffle the rows to mix zero and non-zero samples
    balanced_df = balanced_df.sample(frac=1, random_state=42).reset_index(drop=True)

    # Prepare the data
    X = balanced_df[['Y_values_scaled']].values  # Independent variable (2D)
    y = balanced_df[column].values  # Binary response variable (expression level)

    # Fit a Logistic GAM with a spline term for the 'distance' feature
    gam = LogisticGAM(s(0, n_splines=10)).fit(X, y)

    # Generate predictions for plotting
    X_pred = np.linspace(X.min(), X.max(), 100).reshape(-1, 1)
    y_pred = gam.predict_proba(X_pred)
    y_pred_ci = gam.confidence_intervals(X_pred)  # Confidence intervals

    # Plotting
    fig, ax = plt.subplots(figsize=(2, 2))
    plt.plot(X_pred.flatten(), y_pred, color='#009FB8', label=f'Fit for {column}',linewidth=2)
    plt.fill_between(X_pred.flatten(), y_pred_ci[:, 0], y_pred_ci[:, 1], color='#009FB8', alpha=0.2)  # Confidence interval

    # Customizing the plot
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    ax.set_xticks([])
    plt.xlabel('')
    plt.ylabel(f'{column}')
    plt.xlim(0,1)
    plt.ylim(0,1)
    plt.title('')
    plt.savefig(f'log_gam_fit_{column}.png', bbox_inches='tight', dpi=450)
    plt.show()

from pygam import LogisticGAM, s
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

columns_to_plot=[ 'annotation_pc']

# Iterate over all columns except 'distance'
for column in columns_to_plot:
    # Only process if the column is in the include list
    # Identify non-zero and zero expression rows
    non_zeros = df[df[column] > 0]
    zeros = df[df[column] == 0]
    # Number of samples to match
    n_samples = min(len(non_zeros), len(zeros))

    # Randomly sample from zeros to match the number of non-zero samples
    sampled_zeros = zeros.sample(n=n_samples, random_state=42)
    sampled_non_zeros = non_zeros.sample(n=n_samples, random_state=42)

    # Concatenate the sampled data
    balanced_df = pd.concat([sampled_zeros, sampled_non_zeros])

    # Shuffle the rows to mix zero and non-zero samples
    balanced_df = balanced_df.sample(frac=1, random_state=42).reset_index(drop=True)

    # Prepare the data
    X = balanced_df[['Y_values_scaled']].values  # Independent variable (2D)
    y = balanced_df[column].values  # Binary response variable (expression level)

    # Fit a Logistic GAM with a spline term for the 'distance' feature
    gam = LogisticGAM(s(0, n_splines=10)).fit(X, y)

    # Generate predictions for plotting
    X_pred = np.linspace(X.min(), X.max(), 100).reshape(-1, 1)
    y_pred = gam.predict_proba(X_pred)
    y_pred_ci = gam.confidence_intervals(X_pred)  # Confidence intervals

    # Plotting
    fig, ax = plt.subplots(figsize=(2, 2))
    plt.plot(X_pred.flatten(), y_pred, color='#006AA9', label=f'Fit for {column}',linewidth=2)
    plt.fill_between(X_pred.flatten(), y_pred_ci[:, 0], y_pred_ci[:, 1], color='#006AA9', alpha=0.2)  # Confidence interval

    # Customizing the plot
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    ax.set_xticks([])
    plt.xlabel('')
    plt.ylabel(f'{column}')
    plt.xlim(0,1)
    plt.ylim(0,1)
    plt.title('')
    plt.savefig(f'log_gam_fit_{column}.png', bbox_inches='tight', dpi=450)
    plt.show()

from pygam import LogisticGAM, s
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

columns_to_plot=[ 'annotation_fibro']

# Iterate over all columns except 'distance'
for column in columns_to_plot:
    # Only process if the column is in the include list
    # Identify non-zero and zero expression rows
    non_zeros = df[df[column] > 0]
    zeros = df[df[column] == 0]
    # Number of samples to match
    n_samples = min(len(non_zeros), len(zeros))

    # Randomly sample from zeros to match the number of non-zero samples
    sampled_zeros = zeros.sample(n=n_samples, random_state=42)
    sampled_non_zeros = non_zeros.sample(n=n_samples, random_state=42)

    # Concatenate the sampled data
    balanced_df = pd.concat([sampled_zeros, sampled_non_zeros])

    # Shuffle the rows to mix zero and non-zero samples
    balanced_df = balanced_df.sample(frac=1, random_state=42).reset_index(drop=True)

    # Prepare the data
    X = balanced_df[['Y_values_scaled']].values  # Independent variable (2D)
    y = balanced_df[column].values  # Binary response variable (expression level)

    # Fit a Logistic GAM with a spline term for the 'distance' feature
    gam = LogisticGAM(s(0, n_splines=10)).fit(X, y)

    # Generate predictions for plotting
    X_pred = np.linspace(X.min(), X.max(), 100).reshape(-1, 1)
    y_pred = gam.predict_proba(X_pred)
    y_pred_ci = gam.confidence_intervals(X_pred)  # Confidence intervals

    # Plotting
    fig, ax = plt.subplots(figsize=(2, 2))
    plt.plot(X_pred.flatten(), y_pred, color='#BA877E', label=f'Fit for {column}',linewidth=2)
    plt.fill_between(X_pred.flatten(), y_pred_ci[:, 0], y_pred_ci[:, 1], color='#BA877E', alpha=0.2)  # Confidence interval

    # Customizing the plot
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    ax.set_xticks([])
    plt.xlabel('')
    plt.ylabel(f'{column}')
    plt.xlim(0,1)
    plt.ylim(0,1)
    plt.title('')
    plt.savefig(f'log_gam_fit_{column}.png', bbox_inches='tight', dpi=450)
    plt.show()

from pygam import LogisticGAM, s
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

columns_to_plot=[ 'annotation_endo']

# Iterate over all columns except 'distance'
for column in columns_to_plot:
    # Only process if the column is in the include list
    # Identify non-zero and zero expression rows
    non_zeros = df[df[column] > 0]
    zeros = df[df[column] == 0]
    # Number of samples to match
    n_samples = min(len(non_zeros), len(zeros))

    # Randomly sample from zeros to match the number of non-zero samples
    sampled_zeros = zeros.sample(n=n_samples, random_state=42)
    sampled_non_zeros = non_zeros.sample(n=n_samples, random_state=42)

    # Concatenate the sampled data
    balanced_df = pd.concat([sampled_zeros, sampled_non_zeros])

    # Shuffle the rows to mix zero and non-zero samples
    balanced_df = balanced_df.sample(frac=1, random_state=42).reset_index(drop=True)

    # Prepare the data
    X = balanced_df[['Y_values_scaled']].values  # Independent variable (2D)
    y = balanced_df[column].values  # Binary response variable (expression level)

    # Fit a Logistic GAM with a spline term for the 'distance' feature
    gam = LogisticGAM(s(0, n_splines=10)).fit(X, y)

    # Generate predictions for plotting
    X_pred = np.linspace(X.min(), X.max(), 100).reshape(-1, 1)
    y_pred = gam.predict_proba(X_pred)
    y_pred_ci = gam.confidence_intervals(X_pred)  # Confidence intervals

    # Plotting
    fig, ax = plt.subplots(figsize=(2, 2))
    plt.plot(X_pred.flatten(), y_pred, color='#009540', label=f'Fit for {column}',linewidth=2)
    plt.fill_between(X_pred.flatten(), y_pred_ci[:, 0], y_pred_ci[:, 1], color='#009540', alpha=0.2)  # Confidence interval

    # Customizing the plot
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    ax.set_xticks([])
    plt.xlabel('')
    plt.ylabel(f'{column}')
    plt.xlim(0,1)
    plt.ylim(0,1)
    plt.title('')
    plt.savefig(f'log_gam_fit_{column}.png', bbox_inches='tight', dpi=450)
    plt.show()

from pygam import LogisticGAM, s
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

columns_to_plot=[ 'annotation_pt']

# Iterate over all columns except 'distance'
for column in columns_to_plot:
    # Only process if the column is in the include list
    # Identify non-zero and zero expression rows
    non_zeros = df[df[column] > 0]
    zeros = df[df[column] == 0]
    # Number of samples to match
    n_samples = min(len(non_zeros), len(zeros))

    # Randomly sample from zeros to match the number of non-zero samples
    sampled_zeros = zeros.sample(n=n_samples, random_state=42)
    sampled_non_zeros = non_zeros.sample(n=n_samples, random_state=42)

    # Concatenate the sampled data
    balanced_df = pd.concat([sampled_zeros, sampled_non_zeros])

    # Shuffle the rows to mix zero and non-zero samples
    balanced_df = balanced_df.sample(frac=1, random_state=42).reset_index(drop=True)

    # Prepare the data
    X = balanced_df[['Y_values_scaled']].values  # Independent variable (2D)
    y = balanced_df[column].values  # Binary response variable (expression level)

    # Fit a Logistic GAM with a spline term for the 'distance' feature
    gam = LogisticGAM(s(0, n_splines=10)).fit(X, y)

    # Generate predictions for plotting
    X_pred = np.linspace(X.min(), X.max(), 100).reshape(-1, 1)
    y_pred = gam.predict_proba(X_pred)
    y_pred_ci = gam.confidence_intervals(X_pred)  # Confidence intervals

    # Plotting
    fig, ax = plt.subplots(figsize=(2, 2))
    plt.plot(X_pred.flatten(), y_pred, color='#F3A3C5', label=f'Fit for {column}',linewidth=2)
    plt.fill_between(X_pred.flatten(), y_pred_ci[:, 0], y_pred_ci[:, 1], color='#F3A3C5', alpha=0.2)  # Confidence interval

    # Customizing the plot
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    ax.set_xticks([])
    plt.xlabel('')
    plt.ylabel(f'{column}')
    plt.xlim(0,1)
    plt.ylim(0,1)
    plt.title('')
    plt.savefig(f'log_gam_fit_{column}.png', bbox_inches='tight', dpi=450)
    plt.show()

